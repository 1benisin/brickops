# Story 1.3: External API Credentials and Integration Setup

## Status

Done

## Story

**As a** system administrator,
**I want** secure management of external API credentials,
**so that** the application can integrate with Brickognize, Bricklink, and Brickowl safely.

## Acceptance Criteria

1. **1.3.1:** Document API key acquisition process for Brickognize API
2. **1.3.2:** Document OAuth setup process for Bricklink API integration
3. **1.3.3:** Document API key setup process for Brickowl API
4. **1.3.4:** Implement secure credential storage using Convex environment variables
5. **1.3.5:** Create credential validation utilities for testing API connections
6. **1.3.6:** Set up API rate limiting and error handling framework
7. **1.3.7:** Create API client base classes with proper authentication handling
8. **1.3.8:** Implement retry logic and circuit breaker patterns for API failures
9. **1.3.9:** Add API health check endpoints for monitoring external service status

### Dependencies

- Story 1.2 (testing infrastructure) must be completed so validation utilities and health checks can be covered by unit/integration tests and surfaced in CI.

## Tasks / Subtasks

- [x] Task 1 (AC: 1.3.1, 1.3.3) — Credential acquisition and setup documentation

  - [x] Document Brickognize API key request and storage steps [Source: architecture/api-brickognize.md#documentation]
  - [x] Document Brickowl API key generation and usage patterns [Source: architecture/api-brickowl.md#affiliate-stores]
  - [x] Add docs to `docs/architecture/api-specification.md` referencing locations for environment configuration
  - [x] Define provider env vars and document where to set them in Convex env: `BRICKOGNIZE_API_KEY`, `BRICKOWL_API_KEY` [Source: architecture/security-and-performance.md#secrets]

- [x] Task 2 (AC: 1.3.2) — Bricklink OAuth setup

  - [x] Document OAuth 1.0a parameters and signature requirements [Source: architecture/api-bricklink.md#authentication--authorization]
  - [x] Provide example environment variables required for consumer key/secret and access tokens: `BRICKLINK_CONSUMER_KEY`, `BRICKLINK_CONSUMER_SECRET`, `BRICKLINK_ACCESS_TOKEN`, `BRICKLINK_TOKEN_SECRET` [Source: architecture/api-bricklink.md]

- [x] Task 3 (AC: 1.3.4) — Secure credential storage via Convex env

  - [x] Define Convex environment variables for all external credentials (no hardcoding) [Source: architecture/security-and-performance.md#security-requirements]
  - [x] Verify secrets usage through server-side functions only; never exposed to client

- [x] Task 4 (AC: 1.3.5) — Credential validation utilities

  - [x] Implement lightweight validation functions to ping each external API using configured credentials (non-destructive) [Source: architecture/monitoring-and-observability.md#key-metrics]
  - [x] Add unit/integration tests for validation utilities (Jest/Vitest) using mocks from 1.2

- [x] Task 5 (AC: 1.3.6, 1.3.8) — Rate limiting, retry, and circuit breaker

  - [x] Implement per-user and per-endpoint rate limits where applicable [Source: architecture/security-and-performance.md#security-requirements]
  - [x] Add exponential backoff with jitter and circuit breaker wrappers for external calls [Source: architecture/error-handling-strategy.md]
  - [x] Implement Bricklink daily quota budget manager (default 5,000/day) with soft alert at 80% and enforcement to prevent overage; emit metrics for monitoring.

- [x] Task 6 (AC: 1.3.7) — API client base classes

  - [x] Create shared HTTP client abstractions for Brickognize (API key), Bricklink (OAuth 1.0a), and Brickowl (API key) [Source: architecture/backend-architecture.md#service-architecture-serverless]
  - [x] Centralize auth handling and headers; ensure UTF-8 and SSL constraints for Bricklink [Source: architecture/api-bricklink.md#api-base-url]

- [x] Task 7 (AC: 1.3.9) — Health check endpoints

  - [x] Add Convex HTTP actions to expose health checks for each external API [Source: architecture/backend-architecture.md]
  - [x] Expose GET endpoints: `/api/health/brickognize`, `/api/health/bricklink`, `/api/health/brickowl` via `convex/http.ts`
  - [x] Integrate with monitoring to surface external API status, error rates, and Bricklink daily quota usage (%) with alerts at ≥80% [Source: architecture/monitoring-and-observability.md#backend-metrics]

## Dev Notes

### Previous Story Insights

- Testing stack (Jest/Vitest/Playwright) is in place; reuse mocks and test harness from 1.2 for validation utilities. [Source: docs/stories/1.2.testing-infrastructure-setup.story.md#dev-agent-record]

### Data Models

- All Convex functions must enforce tenant isolation (`businessAccountId`) even for credential validation flows. [Source: architecture/backend-architecture.md#authentication-and-authorization]

### API Specifications

- Brickognize: API key header, image endpoints, health endpoint, validation errors schema. [Source: architecture/api-brickognize.md]
- Bricklink: OAuth 1.0a, HMAC-SHA1 signature, strict SSL/UTF-8, JSON responses with `meta` and `data`. [Source: architecture/api-bricklink.md]
- Brickowl: API key mechanisms, documented rate limits (600 rpm typical). [Source: architecture/api-brickowl.md]

### Component/Service Specifications

- Implement API client base classes under `convex/lib/external/` and keep endpoint-specific helpers under `convex/functions/*` domains. [Source: architecture/source-tree.md]
- Health checks exposed via `convex/http.ts` with minimal surface. [Source: architecture/backend-architecture.md]

### Environment Variables

- Brickognize: `BRICKOGNIZE_API_KEY` (Convex env)
- Bricklink: `BRICKLINK_CONSUMER_KEY`, `BRICKLINK_CONSUMER_SECRET`, `BRICKLINK_ACCESS_TOKEN`, `BRICKLINK_TOKEN_SECRET` (Convex env)
- Brickowl: `BRICKOWL_API_KEY` (Convex env)
- Secrets are never hardcoded and are only read on server side. [Source: architecture/security-and-performance.md#secrets]

### Rate Limits

- External (provider): Brickowl documented at ~600 rpm typical (200 rpm for bulk). Bricklink: default 5,000 calls/day per API Terms (2023-02-02). Brickognize: consult provider docs. [Source: architecture/api-brickowl.md; architecture/api-bricklink.md]
- Internal (per-user): identify = 100/hour; order processing = 50/hour. Enforce at function boundaries. [Source: architecture/security-and-performance.md#security-requirements]

### Error Mapping

- Normalize provider errors into `ApiError`:
  - Brickognize 422 validation → `{ error: { code: "VALIDATION_ERROR", message, details } }` [Source: architecture/api-brickognize.md#error-responses; architecture/error-handling-strategy.md]
  - Bricklink non-2xx with `meta` → map `meta.code`/`meta.message` to `error.code`/`error.message` and include `data` in `details` when safe. [Source: architecture/api-bricklink.md#error-handling; architecture/error-handling-strategy.md]
  - Brickowl non-2xx → map provider message to `error.code`/`error.message` with request context in `details` (no secrets). [Source: architecture/error-handling-strategy.md]

### File Locations

- Backend clients: `convex/lib/external/{brickognize|bricklink|brickowl}.ts`
- Validation utilities: `convex/lib/external/validate.ts`
- Health checks: `convex/http.ts`
- Docs updates: `docs/architecture/api-specification.md`
  [Source: architecture/unified-project-structure.md]

### Testing Requirements

- Unit tests for credential validation utilities and client auth header/signing behavior (mock only).
- Integration tests for Convex HTTP actions exposure paths.
- E2E is not required for credential setup; verify via health endpoints in CI.
  [Source: architecture/testing-strategy.md]

### Technical Constraints

- No secrets in code; use environment variables managed by Convex. [Source: architecture/security-and-performance.md#security-requirements]
- Rate limiting aligned with documented per-user limits; external APIs may impose their own quotas. [Source: architecture/security-and-performance.md]
- Use exponential backoff with jitter and circuit breakers for resiliency. [Source: architecture/error-handling-strategy.md]

### Project Structure Notes

- Follow documented source tree; place shared clients in `convex/lib/external` and domain usage in respective `convex/functions/*` files. [Source: architecture/source-tree.md]

## Testing

- Validate health endpoints return expected statuses when mocks simulate success/failure.
- Confirm Bricklink OAuth signing flow is exercised via unit tests (no live calls).
- Ensure rate limiting and circuit breaker wrappers are covered by unit tests.
- OAuth signing tests: verify Authorization header includes HMAC-SHA1 signature, timestamp, and nonce; assert base-string canonicalization and signature generation via deterministic mocks. [Source: architecture/api-bricklink.md#authentication--authorization]
- CI check: probe `/api/health/brickognize|bricklink|brickowl` endpoints in a mocked environment to verify wiring.
- Budget tests: simulate Bricklink request counting to confirm soft-alert at 80% of 5,000/day and hard-stop beyond quota; verify metrics emission.

## Change Log

| Date       | Version | Description                                            | Author             |
| ---------- | ------- | ------------------------------------------------------ | ------------------ |
| 2025-09-21 | 0.1     | Initial story draft created                            | Bob (Scrum Master) |
| 2025-09-21 | 0.2     | Hardened health-check error handling after QA findings | James (Developer)  |

## Dev Agent Record

### Agent Model Used

Codex GPT-5

### Debug Log References

- pnpm test:backend (QA fixes verification)

### Completion Notes List

- Established Convex external client layer with rate limiting, retries, circuit breaker, and Bricklink quota governance plus monitoring metrics.
- Documented credential acquisition and Convex environment setup for Brickognize, Bricklink, and Brickowl in architecture references.
- Added validation utilities, health endpoints, and backend tests covering OAuth signing, quota alerts, and provider health reporting.
- Hardened external API health-check error handling to return structured failures and added regression tests for quota exhaustion and shared rate-limiter scenarios.

### File List

- docs/stories/1.3.external-api-credentials-and-integration-setup.story.md
- docs/architecture/api-bricklink.md
- docs/architecture/api-brickognize.md
- docs/architecture/api-brickowl.md
- docs/architecture/api-specification.md
- convex/http.ts
- convex/lib/external/bricklink.ts
- convex/lib/external/brickognize.ts
- convex/lib/external/brickowl.ts
- convex/lib/external/circuitBreaker.ts
- convex/lib/external/env.ts
- convex/lib/external/httpClient.ts
- convex/lib/external/metrics.ts
- convex/lib/external/rateLimiter.ts
- convex/lib/external/retry.ts
- convex/lib/external/types.ts
- convex/lib/external/validate.ts
- **tests**/backend/external/bricklink-client.test.ts
- **tests**/backend/external/validation-utils.test.ts

## QA Results

### Review Date: 2025-09-21

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

- External client abstractions are consistent and reuse shared retry/rate limiting primitives, and OAuth signature construction matches Bricklink requirements.
- Error handling assumes every failure surfaces as an `ApiError`; when local guards (quota, circuit breaker, rate limiter) throw plain `Error`s the health-check catch blocks dereference `apiError.error` and crash instead of returning a structured result.

### Test Coverage & Evidence

- Executed `pnpm test:backend` (Vitest); new suites cover OAuth signing and quota alerts plus validation happy-paths.
- No automated coverage for health-check failure paths (quota exhaustion, circuit-breaker open) or HTTP error surfaces from Brickowl/Brickognize clients, leaving the faulty error handling untested.

### NFR Validation

- Security: Secrets stay in Convex env vars with helper accessors; Bricklink OAuth signing enforces SSL/UTF-8 constraints. Risk: health endpoints expose raw error messages when the catch block crashes.
- Reliability/Performance: Retry + circuit breaker wired, but failure to safely surface non-HTTP errors undermines resilience signalling.

### Testability & Observability

- Metric emitters cover quota usage and health results; listeners allow inspection in tests. Missing hooks to spy on circuit-breaker transitions or rate-limit exhaustion keeps critical paths under-observed.

### Issues Found

- **FAIL** – Health checks crash on non-HTTP failures. `BricklinkClient.healthCheck` (refs: `convex/lib/external/bricklink.ts:232-247`), `BrickognizeClient.healthCheck` (`convex/lib/external/brickognize.ts:62-77`), and `BrickowlClient.healthCheck` (`convex/lib/external/brickowl.ts:67-83`) cast every caught error to `ApiError` and immediately access `apiError.error.code`. When local guards (quota exhaustion, shared rate limiter, circuit breaker) throw generic `Error`s this becomes `Cannot read properties of undefined`, causing the validator to throw and the `/api/health/*` endpoints to respond 500 without actionable diagnostics.

### Recommended Status

- Changes Required – address the error-handling bug and add regression coverage around quota/circuit-breaker failures.

### Review Date: 2025-09-21

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

- Verified new `normalizeApiError` guard wraps non-HTTP failures before returning from each provider health check, preventing undefined dereferences (`convex/lib/external/types.ts:61`, `convex/lib/external/bricklink.ts:233`).
- Health checks now surface structured `ValidationResult` objects so `/api/health/*` endpoints avoid 500s when local protections trigger.

### Test Coverage & Evidence

- `pnpm test:backend` (Vitest) – includes new regression cases for Bricklink quota exhaustion and shared rate limiter failures ensuring structured error paths remain intact.
- Added tests assert we still skip outgoing requests when quota/rate caps are hit while emitting the expected metrics events.

### NFR Validation

- Security: PASS – no regression; secrets remain server-side only.
- Performance: PASS – retry/backoff logic unchanged; no added cost.
- Reliability: PASS – health checks gracefully degrade under guard-triggered failures.
- Maintainability: PASS – regression tests codify the failure handling contract.

### Testability & Observability

- Metrics coverage now includes failure events; rate limiter scenario is exercised via unit tests enabling future diagnostics.

### Issues Found

- None – previous high-severity defect resolved.

### Recommended Status

- Ready for Done – implementation meets ACs with resilient health monitoring.
