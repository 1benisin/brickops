# Story 3.3: BrickOwl Store Client (Inventory Lots + Mappers)

## Status

Done

## Story

**As a** system,
**I want** a robust BrickOwl client with inventory lot CRUD and data mappers,
**so that** we can synchronize our users' store inventory to/from BrickOwl in a reliable and maintainable way.

## Acceptance Criteria

1. **3.3.1:** Implement a typed BrickOwl client that authenticates with user-provided credentials (API key format) and supports required authentication headers.
2. **3.3.2:** Provide CRUD operations for store inventory lots: create lot, read/get lot(s), update lot, delete lot; include list/pagination support where the API allows.
3. **3.3.3:** Implement data mappers to transform BrickOwl request/response payloads into our Convex `inventories` schema shapes and back (including fields like part identifier, condition, quantity, price, location, remarks/notes, status).
4. **3.3.4:** Support bulk operations using BrickOwl's native bulk batch endpoint (up to 50 requests per batch); provide chunked/sequenced operations with progress and partial-failure reporting.
5. **3.3.5:** Add resiliency: handle rate limits and transient failures via exponential backoff, retry policies, and idempotency (dedupe by request keys).
6. **3.3.6:** Provide structured logging (with correlation IDs) and metrics around request counts, latency, errors, and throttle events; no secrets in logs.

## Tasks / Subtasks

- [x] Task 1: Create authentication module and specialized inventory client (AC: 3.3.1)

  - [x] **Create Shared Auth Module**: Create `convex/brickowl/auth.ts` module with reusable API key authentication functions:
    - Create `buildAuthHeaders(apiKey)` helper for constructing authentication headers
    - Create `validateApiKey(apiKey)` helper for API key format validation
    - Add `generateRequestId()` helper for unique request identification
    - CRITICAL: Make functions pure and testable (accept API key as parameter, not from env)
  - [x] **Create New Store Client** (`convex/brickowl/storeClient.ts`):
    - New class that accepts user credentials and `businessAccountId` as constructor arguments
    - Use shared auth functions from `auth.ts` for authentication
    - Implement database-backed rate limiting (pre-flight check + post-request recording)
    - Implement store inventory CRUD methods
    - CRITICAL: Use user credentials passed to constructor (NOT env variables)
    - NOTE: Named "Store" not "Inventory" - will also handle orders in Epic 4
  - [x] Add validation to ensure API key is properly formatted before making requests
  - [x] [Source: docs/architecture/backend-architecture.md#actions-external-api-orchestration; docs/external-documentation/api-brickowl/store-inventory.md; docs/stories/3.1.user-marketplace-credentials-byok-on-settings.story.md#dev-notes]

- [x] Task 2: Implement inventory lot CRUD operations (AC: 3.3.2)

  - [x] Implement `getInventories(options?: { type?, active_only?, external_id?, lot_id? })` method for listing inventory lots with filtering support (maps to `GET /v1/inventory/list`)
  - [x] Implement `getInventory(lotId: string)` method for fetching single inventory lot (maps to `GET /v1/inventory/list` with lot_id filter)
  - [x] Implement `createInventory(payload)` method for creating single inventory lot (maps to `POST /v1/inventory/create`)
  - [x] Implement `updateInventory(lotId: string, payload)` method for updating single inventory lot (maps to `POST /v1/inventory/update`)
  - [x] Implement `deleteInventory(lotId: string)` method for deleting single inventory lot (maps to `POST /v1/inventory/delete`)
  - [x] CRITICAL: Support both absolute_quantity and relative_quantity update modes per BrickOwl API requirements
  - [x] CRITICAL: Handle external_id (our SKU/reference) and lot_id (BrickOwl's ID) as dual identifier system
  - [x] [Source: docs/external-documentation/api-brickowl/store-inventory.md; docs/prd/epic-3-inventory-management.md#story-33]

- [x] Task 3: Implement data mappers for BrickOwl <-> Convex schema (AC: 3.3.3)

  - [x] Create `convex/brickowl/storeMappers.ts` with bidirectional mapper functions for store data (inventory now, orders in Epic 4)
  - [x] Implement `mapBrickOwlToConvexInventory(brickowlInventory)` to transform BrickOwl inventory response to our `inventoryItems` schema (map: `lot_id` → `brickowlLotId`, `boid` → `partNumber`, `color_id` → `colorId`, `quantity` → `quantityAvailable`, `condition` → `condition`, `price` → `price`, `personal_note`/`public_note` → `notes`, `external_id` → external reference tracking)
  - [x] Implement `mapConvexToBrickOwlInventory(convexInventory)` to transform our inventory to BrickOwl create/update payload (reverse mapping with proper field names and format)
  - [x] Handle optional fields gracefully (e.g., BrickOwl's tier_price, bulk_qty, sale_percent)
  - [x] Include TypeScript types for BrickOwl inventory request/response shapes based on API documentation
  - [x] Add validation for required fields and proper enum values (condition codes, item type)
  - [x] [Source: docs/external-documentation/api-brickowl/store-inventory.md; docs/architecture/data-models.md#inventoryitem; docs/architecture/backend-architecture.md#function-template]

- [x] Task 4: Implement bulk operations using native batch API (AC: 3.3.4)

  - [x] **BULK OPERATIONS (Native BrickOwl Batch API - Efficient)**:
    - Implement `bulkBatchOperations(requests[], options?: { chunkSize?, onProgress? })` that uses BrickOwl's `/v1/bulk/batch` endpoint
    - Batch up to 50 requests per API call (BrickOwl maximum)
    - Support mixed operation types in single batch (create, update, delete)
    - Each batch request specifies: `endpoint`, `request_method` (GET/POST), `params`
    - Returns array of responses matching request order
  - [x] **BULK CREATE**:
    - Implement `bulkCreateInventories(payloads[], options?)` that chunks into batches and calls native batch API
    - Default chunk size: 50 items per batch (BrickOwl limit)
    - More efficient than BrickLink: 50 creates = 1 API call
  - [x] **BULK UPDATE**:
    - Implement `bulkUpdateInventories(updates[], options?)` that sequences individual updates via batch API
    - Use batch endpoint to process up to 50 updates per call
    - More efficient than BrickLink sequential: 50 updates = 1 API call vs 50 calls
  - [x] **BULK DELETE**:
    - Implement `bulkDeleteInventories(ids[], options?)` that sequences individual deletes via batch API
    - Use batch endpoint for efficiency: 50 deletes = 1 API call
  - [x] **Common Bulk Features**:
    - Add progress callback: `onProgress({ completed: number, total: number, currentBatch: number, totalBatches: number })`
    - Track partial failures: collect all errors with context (batch index, request index, error details) and return comprehensive result: `{ succeeded: number, failed: number, errors: Array<{ batchIndex, requestIndex, request, error }> }`
    - Add idempotency: dedupe requests by generating stable request key (hash of payload) and skip duplicate operations within same bulk batch
    - CRITICAL: Support external idempotency keys via `options.idempotencyKey?` parameter - Story 3.4 will pass change log IDs for deduplication across retry attempts
    - Return structured result for each operation: `{ success: boolean, brickowlLotId?: string, error?: { code, message, details }, marketplaceStatus?: string }` to support Story 3.4 sync status tracking
  - [x] **Rate Limit Optimization**: Track API calls consumed: bulk batch of 50 items = 1 call for any operation type
  - [x] [Source: docs/external-documentation/api-brickowl/store-inventory.md; docs/external-documentation/api-brickowl/bulk-requests.md; docs/prd/epic-3-inventory-management.md#story-33; docs/prd/epic-3-inventory-management.md#story-34; docs/architecture/backend-architecture.md#actions-external-api-orchestration]

- [x] Task 5: Database-backed rate limiting (AC: 3.3.5 - per-user quota tracking)

  - [x] Reuse existing `marketplaceRateLimits` table from Story 3.2 (already supports multi-provider via provider field)
  - [x] Extend internal queries in `convex/functions/marketplace.ts`: `getQuotaState(businessAccountId, "brickowl")` returns current quota usage
  - [x] Extend internal mutation: `incrementQuota(businessAccountId, "brickowl")` atomically increments request count with window reset logic
  - [x] In `BrickOwlStoreClient.request()`: implement pre-flight quota check by calling `getQuotaState()` before making API request
  - [x] If quota exceeded, throw `ConvexError` with code `RATE_LIMIT_EXCEEDED`, include `retryAfterMs` for Story 3.4 retry scheduling
  - [x] In `BrickOwlStoreClient.request()`: implement post-request quota recording by calling `incrementQuota()` after successful API call
  - [x] Add quota alert at 80% threshold: emit metric `external.brickowl.store.quota.alert` when business account reaches warning level
  - [x] CRITICAL: Quota tracking is per business account (tenant-isolated) and separate from BrickLink quota
  - [x] CRITICAL: Set appropriate capacity for BrickOwl (research their documented rate limits, default to conservative estimate if not published)
  - [x] [Source: docs/architecture/backend-architecture.md#actions-external-api-orchestration; docs/prd/epic-3-inventory-management.md#story-33; docs/stories/3.2.bricklink-client-inventory.story.md#database-backed-rate-limiting-architecture]

- [x] Task 6: Resiliency patterns (AC: 3.3.5)

  - [x] Implement exponential backoff for transient failures (HTTP 5xx, network errors): start with 1s delay, double each retry up to max 32s, max 5 retries
  - [x] Handle BrickOwl HTTP 429 responses: extract `Retry-After` header if available, implement respectful backoff
  - [x] Implement circuit breaker pattern: if 5 consecutive failures for a business account, temporarily disable that account's BrickOwl sync for 5 minutes (track in `marketplaceRateLimits` table with `circuitBreakerOpenUntil` field)
  - [x] Add retry policy configuration: `{ maxRetries: 5, initialDelayMs: 1000, maxDelayMs: 32000, backoffMultiplier: 2 }`
  - [x] CRITICAL: Never retry non-idempotent operations (POST create without idempotency key) automatically; only retry safe operations (GET, idempotent POST/PUT/DELETE)
  - [x] [Source: docs/architecture/backend-architecture.md#actions-external-api-orchestration; docs/architecture/coding-standards.md#critical-rules]

- [x] Task 7: Structured logging and metrics (AC: 3.3.6)

  - [x] Add correlation ID generation for all operations: `crypto.randomUUID()` passed through entire request chain
  - [x] Use existing `recordMetric()` helper from `convex/lib/external/metrics.ts` for tracking: `external.brickowl.store.request`, `external.brickowl.store.success`, `external.brickowl.store.error`, `external.brickowl.store.retry`, `external.brickowl.store.quota`
  - [x] Log request metadata: `{ correlationId, operation, businessAccountId, itemCount (for bulk), durationMs, retryCount }`
  - [x] Log error details: `{ correlationId, operation, errorCode, errorMessage, httpStatus, businessAccountId }` - NEVER log API key values or auth headers
  - [x] Add metric for bulk operation progress: `external.brickowl.store.bulk.progress { completed, total, batchIndex }`
  - [x] Reuse existing `normalizeApiError()` from `convex/lib/external/types.ts` for consistent error formatting
  - [x] [Source: docs/architecture/backend-architecture.md#convex-function-patterns-and-best-practices; docs/prd/epic-3-inventory-management.md#story-33]

- [x] Task 8: Client factory with credential decryption (Story 3.1 integration)

  - [x] Extend internal action `marketplace.createBrickOwlStoreClient(businessAccountId)` in `convex/functions/marketplace.ts`
  - [x] Action queries `marketplaceCredentials` table for the business account's BrickOwl credentials (provider: "brickowl")
  - [x] If no credentials found or inactive, throw `ConvexError` with user-friendly message: "BrickOwl credentials not configured. Please add your credentials in Settings."
  - [x] Decrypt credentials using `decryptCredential()` from `convex/lib/encryption.ts`
  - [x] Instantiate `BrickOwlStoreClient` with: decrypted credentials, businessAccountId, AND ActionCtx (`ctx`) - client needs ctx for DB rate limiting
  - [x] Return client instance ready for store operations (inventory now, orders in Epic 4)
  - [x] Add RBAC check: only owner role can trigger store sync operations (check in Story 3.4 orchestration layer, not here)
  - [x] CRITICAL: Client constructor signature is `new BrickOwlStoreClient(credentials, businessAccountId, ctx)` - ctx enables database queries/mutations for quota tracking
  - [x] [Source: docs/stories/3.1.user-marketplace-credentials-byok-on-settings.story.md#dev-notes; docs/architecture/backend-architecture.md#authentication-and-authorization; docs/architecture/backend-architecture.md#internal-functions-server-only-building-blocks]

- [x] Task 9: Rollback and compensating operations support (Story 3.4 rollback capability)

  - [x] All CRUD operations already support rollback pattern: `createInventory` → `deleteInventory`, `deleteInventory` → `createInventory` (with same payload), `updateInventory` → `updateInventory` (with previous values)
  - [x] Ensure all operation responses include enough information for Story 3.4 to construct compensating operations: `{ brickowlLotId, previousQuantity?, previousPrice?, etc. }`
  - [x] Document rollback patterns in Dev Notes: for each operation type, specify the inverse operation and required data
  - [x] Add support for "dry-run" mode via `options.dryRun?: boolean` - validates operation without executing (for Story 3.4 rollback preview)
  - [x] Extend `convex/marketplaces/types.ts` with BrickOwl-specific types if needed (reuse `StoreOperationResult` interface)
  - [x] [Source: docs/prd/epic-3-inventory-management.md#story-34-ac-347; docs/architecture/backend-architecture.md#actions-external-api-orchestration; docs/stories/3.2.bricklink-client-inventory.story.md#integration-with-story-34-orchestration-layer]

## Dev Notes

### Quick Reference: Parallel Architecture with BrickLink

**BrickOwl Store Client** follows the exact same architectural pattern as BrickLink Store Client from Story 3.2:

| Aspect                 | BrickLink Client (Story 3.2)             | BrickOwl Client (Story 3.3)             |
| ---------------------- | ---------------------------------------- | --------------------------------------- |
| **Authentication**     | OAuth 1.0a (4 credentials)               | API Key (single key)                    |
| **Auth Module**        | `bricklink/oauth.ts`                     | `brickowl/auth.ts`                      |
| **Store Client**       | `bricklink/storeClient.ts`               | `brickowl/storeClient.ts`               |
| **Store Mappers**      | `bricklink/storeMappers.ts`              | `brickowl/storeMappers.ts`              |
| **Rate Limiting**      | Database-backed (per-tenant)             | Database-backed (per-tenant)            |
| **Quota Pool**         | Independent per business account         | Independent per business account        |
| **Methods**            | Store operations (inventory + orders)    | Store operations (inventory + orders)   |
| **Instantiation**      | Factory per request (user-specific)      | Factory per request (user-specific)     |
| **Tenant Context**     | Requires `businessAccountId`             | Requires `businessAccountId`            |
| **Bulk Support**       | Native bulk CREATE only (100 items/call) | **Native batch API (50 requests/call)** |
| **Credentials Source** | User database (BYOK)                     | User database (BYOK)                    |

**Key Architectural Advantage: BrickOwl's Batch API**

Unlike BrickLink which only supports native bulk for CREATE operations, BrickOwl provides a universal batch endpoint (`/v1/bulk/batch`) that accepts up to 50 requests of ANY type in a single API call. This makes BrickOwl significantly more efficient for UPDATE and DELETE operations.

**Efficiency Comparison:**

| Operation  | BrickLink (Story 3.2)     | BrickOwl (Story 3.3)            |
| ---------- | ------------------------- | ------------------------------- |
| 50 CREATEs | 1 API call (native bulk)  | 1 API call (via batch)          |
| 50 UPDATEs | 50 API calls (sequential) | **1 API call (via batch)** ⭐   |
| 50 DELETEs | 50 API calls (sequential) | **1 API call (via batch)** ⭐   |
| Mixed ops  | Multiple calls            | **1 API call (mixed batch)** ⭐ |

This architectural difference means BrickOwl sync will be **significantly faster** for update-heavy workloads and consume far less quota.

### Previous Story Insights

- **Story 3.1 (User Marketplace Credentials)**: Established secure credential storage with encryption at rest and test connection functionality. BrickOwl uses simpler API key authentication compared to BrickLink's OAuth 1.0a, making the authentication flow more straightforward.
- **Story 3.2 (BrickLink Store Client)**: Set the architectural pattern for marketplace store clients. This story replicates that pattern exactly: separate specialized client, database-backed rate limiting, comprehensive resiliency, structured logging, and Story 3.4 integration support.
- **Architectural Pattern Reuse**: By following Story 3.2's pattern exactly, we maintain consistency across marketplace integrations and enable Story 3.4's orchestration layer to work with both providers using the same interface.
- [Source: docs/stories/3.1.user-marketplace-credentials-byok-on-settings.story.md; docs/stories/3.2.bricklink-client-inventory.story.md]

### CRITICAL: Parallel Client Architecture (Consistent with Story 3.2)

**Directory Structure (After Story 3.3):**

```text
convex/
├── bricklink/
│   ├── catalogClient.ts       # Catalog client (renamed from bricklinkClient.ts)
│   ├── bricklinkMappers.ts    # Catalog mappers (unchanged)
│   ├── dataRefresher.ts       # Catalog refresh jobs (unchanged)
│   ├── oauth.ts               # OAuth 1.0a helpers (Story 3.2)
│   ├── storeClient.ts         # Store client (Story 3.2)
│   └── storeMappers.ts        # Store mappers (Story 3.2)
│
├── brickowl/                  # NEW FOLDER - Story 3.3
│   ├── auth.ts                # NEW - API key authentication helpers
│   ├── storeClient.ts         # NEW - Store client (inventory + future orders)
│   └── storeMappers.ts        # NEW - Store data mappers
│
├── marketplaces/
│   └── types.ts               # Shared TypeScript interfaces (Story 3.2, extended in 3.3)
│
├── functions/
│   ├── marketplace.ts         # EXTEND - Add createBrickOwlStoreClient() factory
│   └── inventory.ts           # Business logic (unchanged)
```

**Naming Consistency:**

- Both use "Store" not "Inventory" - encompasses inventory + orders + settings
- Both follow factory pattern via `createXStoreClient(businessAccountId)`
- Both use database-backed rate limiting via `marketplaceRateLimits` table
- Both return `StoreOperationResult` for Story 3.4 integration

**Never Mix Credentials:**

```typescript
// ❌ WRONG - Using wrong provider's store client
const bricklinkStoreClient = await createBricklinkStoreClient(ctx, businessAccountId);
await bricklinkStoreClient.createInventory(...); // This goes to BrickLink!

const brickowlStoreClient = await createBrickOwlStoreClient(ctx, businessAccountId);
await brickowlStoreClient.createInventory(...); // This goes to BrickOwl!
// They are NOT interchangeable!

// ✅ CORRECT - Use appropriate store client for each provider
// Story 3.4 will determine which providers to sync based on user's configured credentials
const providers = await getConfiguredProviders(businessAccountId);

if (providers.includes("bricklink")) {
  const bricklinkStoreClient = await createBricklinkStoreClient(ctx, businessAccountId);
  await syncToBricklink(bricklinkStoreClient, changes);
}

if (providers.includes("brickowl")) {
  const brickowlStoreClient = await createBrickOwlStoreClient(ctx, businessAccountId);
  await syncToBrickOwl(brickowlStoreClient, changes);
}
```

[Source: docs/architecture/backend-architecture.md#internal-functions-server-only-building-blocks; docs/stories/3.2.bricklink-client-inventory.story.md#critical-separate-specialized-clients-architecture]

### Database-Backed Rate Limiting Architecture

**Reuses Story 3.2 Infrastructure:**

The `marketplaceRateLimits` table created in Story 3.2 already supports multiple providers via the `provider` field. BrickOwl simply uses `provider: "brickowl"` instead of `provider: "bricklink"`.

**Rate Limit Capacity for BrickOwl:**

Research BrickOwl's published rate limits. Common API rate limits are:

- 1,000 requests/day (conservative services)
- 5,000 requests/day (standard services, same as BrickLink)
- 10,000 requests/day (premium services)

**Default Recommendation**: Start with 5,000 requests/day (same as BrickLink) and adjust based on:

1. BrickOwl's actual published limits (check their API documentation)
2. User feedback about rate limit errors
3. Circuit breaker activation patterns

**Implementation Pattern (Identical to Story 3.2):**

```typescript
// Client pre-flight check
class BrickOwlStoreClient {
  async request(options) {
    // 1. Check quota BEFORE making request
    const quota = await ctx.runQuery(internal.marketplace.getQuotaState, {
      businessAccountId: this.businessAccountId,
      provider: "brickowl", // Only difference from BrickLink
    });

    // Same quota checking logic as BrickLink...
    // Same circuit breaker logic as BrickLink...

    // 2. Make API request
    const response = await fetch(url, {
      headers: {
        Authorization: this.apiKey, // Simpler than BrickLink OAuth
        ...
      }
    });

    // 3. Record quota usage AFTER successful request
    await ctx.runMutation(internal.marketplace.incrementQuota, {
      businessAccountId: this.businessAccountId,
      provider: "brickowl",
    });

    return response;
  }
}
```

**Per-Provider Quota Isolation:**

Each provider has completely independent quota tracking:

- BrickLink: 5,000 requests/day per business account
- BrickOwl: X requests/day per business account (to be determined)
- Future providers: Independent quotas

User can hit both providers' rate limits independently without affecting each other.

[Source: docs/stories/3.2.bricklink-client-inventory.story.md#database-backed-rate-limiting-architecture]

### Bulk Operations Strategy: BrickOwl's Batch API Advantage

**BrickOwl Batch Endpoint Specification:**

```typescript
// POST /v1/bulk/batch
{
  "requests": [
    {
      "endpoint": "inventory/create",
      "request_method": "POST",
      "params": [{ "boid": "12345", "quantity": 10, "price": 1.50, ... }]
    },
    {
      "endpoint": "inventory/update",
      "request_method": "POST",
      "params": [{ "lot_id": "ABC123", "relative_quantity": 5 }]
    },
    {
      "endpoint": "inventory/delete",
      "request_method": "POST",
      "params": [{ "lot_id": "XYZ789" }]
    }
  ]
}

// Response: Array of responses in same order as requests
[
  { /* result for create */ },
  { /* result for update */ },
  { /* result for delete */ }
]
```

**Batch API Key Features:**

1. **Mixed Operations**: Can batch different operation types (create, update, delete) in single call
2. **Maximum 50 Requests**: Per batch (BrickOwl limit)
3. **Ordered Responses**: Response array matches request order
4. **Individual Results**: Each operation has success/failure independently
5. **Significant Efficiency**: 50 operations = 1 API call (any operation type)

**Implementation Strategy:**

```typescript
// Efficient bulk update implementation
async bulkUpdateInventories(updates: Array<UpdatePayload>, options?: BulkOptions) {
  const chunks = chunkArray(updates, 50); // BrickOwl max
  const results: BulkOperationResult[] = [];

  for (const [batchIndex, chunk] of chunks.entries()) {
    // Build batch request
    const batchRequest = {
      requests: chunk.map(update => ({
        endpoint: "inventory/update",
        request_method: "POST",
        params: [{
          lot_id: update.lotId,
          ...mapConvexToBrickOwlUpdate(update)
        }]
      }))
    };

    // Single API call for 50 updates!
    const response = await this.request({
      method: "POST",
      path: "/v1/bulk/batch",
      body: batchRequest
    });

    // Process batch results
    for (const [index, result] of response.entries()) {
      results.push({
        success: !result.error,
        brickowlLotId: result.lot_id,
        error: result.error ? normalizeApiError(result.error) : undefined
      });
    }

    // Progress callback
    options?.onProgress?.({
      completed: (batchIndex + 1) * chunk.length,
      total: updates.length,
      currentBatch: batchIndex + 1,
      totalBatches: chunks.length
    });
  }

  return aggregateResults(results);
}
```

**Efficiency Comparison with BrickLink:**

| Scenario             | BrickLink (Story 3.2)      | BrickOwl (Story 3.3) | Efficiency Gain              |
| -------------------- | -------------------------- | -------------------- | ---------------------------- |
| **Create 500 items** | 5 API calls (bulk)         | 10 API calls (batch) | BrickLink better (2x)        |
| **Update 500 items** | 500 API calls (sequential) | 10 API calls (batch) | **BrickOwl better (50x)** ⭐ |
| **Delete 500 items** | 500 API calls (sequential) | 10 API calls (batch) | **BrickOwl better (50x)** ⭐ |
| **Mixed ops (500)**  | >500 API calls             | 10 API calls (batch) | **BrickOwl better (50x)** ⭐ |

**Story 3.4 Integration - Sync Efficiency:**

When Story 3.4 implements the orchestration layer:

- **Initial bulk sync** (all creates): BrickLink slightly more efficient (100 items/call vs 50)
- **Ongoing sync** (mixed operations): **BrickOwl dramatically more efficient** due to batch API
- **Update-heavy workloads**: BrickOwl will sync 50x faster and consume 50x less quota
- **Real-world scenario**: User adjusts 100 prices → BrickLink: 100 API calls, BrickOwl: 2 API calls

[Source: docs/external-documentation/api-brickowl/bulk-requests.md; docs/stories/3.2.bricklink-client-inventory.story.md#bulk-operations-strategy-for-api-efficiency]

### Data Models

**BrickOwl Inventory API Response Shape:**

```typescript
interface BrickOwlInventoryResponse {
  lot_id: string; // BrickOwl's internal lot identifier
  boid: string; // BrickOwl item identifier (part number)
  type:
    | "Part"
    | "Set"
    | "Minifigure"
    | "Gear"
    | "Sticker"
    | "Minibuild"
    | "Instructions"
    | "Packaging";
  color_id?: number; // Required for Parts, optional for Gear/Minibuild
  quantity: number;
  price: number; // Number (not string like BrickLink)
  condition:
    | "new"
    | "news"
    | "newc"
    | "newi"
    | "usedc"
    | "usedi"
    | "usedn"
    | "usedg"
    | "useda"
    | "other";
  for_sale: 0 | 1; // Available for sale flag
  absolute_quantity?: number; // For updates: set exact quantity
  relative_quantity?: number; // For updates: adjust by delta (+/-)
  sale_percent?: number; // Sale percentage (-95 to 95)
  my_cost?: number; // Personal cost tracking
  lot_weight?: number; // Custom weight in grams
  personal_note?: string;
  public_note?: string;
  bulk_qty?: number; // Bulk quantity (must buy in multiples)
  tier_price?: string; // Format: "qty:price,qty:price" (e.g., "100:0.05,200:0.04")
  external_id_1?: string; // Optional external reference (our SKU)
}
```

**Key Differences from BrickLink:**

| Field              | BrickLink                | BrickOwl                  | Notes                    |
| ------------------ | ------------------------ | ------------------------- | ------------------------ |
| **ID Field**       | `inventory_id` (number)  | `lot_id` (string)         | Different type!          |
| **Part Number**    | `item.no` (nested)       | `boid` (top-level)        | Simpler structure        |
| **Price**          | String with decimals     | Number                    | Easier to work with      |
| **Condition**      | `N`/`U`                  | Full enum codes           | More detailed            |
| **Quantity Delta** | `"+5"` string prefix     | `relative_quantity` field | Separate field vs prefix |
| **External Ref**   | None (inventory_id only) | `external_id_1`           | Can store our SKU!       |

[Source: docs/external-documentation/api-brickowl/store-inventory.md]

**Convex inventoryItems Schema (Target Mapping):**

```typescript
{
  businessAccountId: Id<"businessAccounts">;
  sku: string; // Maps to external_id_1 in BrickOwl
  name: string;
  partNumber: string; // Maps from boid
  colorId: string; // Maps from color_id (converted to string)
  location: string; // Not directly supported in BrickOwl, tracked locally
  quantityAvailable: number; // Maps from quantity
  quantityReserved: number;
  quantitySold: number;
  status: "available" | "reserved" | "sold";
  condition: "new" | "used"; // Maps from condition (simplified)
  price?: number; // Maps from price (number)
  notes?: string; // Maps from personal_note or public_note
  brickowlLotId?: string; // Maps from lot_id (track BrickOwl sync)
  bricklinkInventoryId?: number; // From Story 3.2 (track BrickLink sync)
  createdBy: Id<"users">;
  createdAt: number;
  updatedAt?: number;
  isArchived?: boolean;
  deletedAt?: number;
}
```

**Dual Marketplace Tracking:**

Note that `inventoryItems` will have **both** `brickOwlLotId` and `bricklinkInventoryId` fields. This enables:

- Single inventory item synced to both marketplaces
- Independent sync status per marketplace
- Marketplace-specific IDs for update/delete operations
- Story 3.4 orchestration can manage multi-marketplace sync

**Mapping Strategy:**

- **External ID Advantage**: Use `external_id_1` to store our `sku` - enables efficient lookups when pulling from BrickOwl
- **Condition Simplification**: Map BrickOwl's detailed condition codes to our simplified `new`/`used` enum (store full condition in notes if needed)
- **Quantity Updates**: Support both absolute (`absolute_quantity`) and relative (`relative_quantity`) - choose based on Story 3.4's sync strategy
- **Location Handling**: BrickOwl doesn't support location field - track separately in Convex, don't sync to BrickOwl
- **Dual Sync Tracking**: Store both marketplace IDs to enable multi-marketplace sync

[Source: docs/external-documentation/api-brickowl/store-inventory.md; docs/architecture/database-schema.md#inventoryitems; docs/architecture/data-models.md#inventoryitem]

### API Specifications

**BrickOwl Inventory Endpoints:**

```typescript
// List inventories (bulk read)
GET /v1/inventory/list?type={type}&active_only={0|1}&external_id_1={id}&lot_id={id}
Response: Array of BrickOwlInventoryResponse
Note: Returns array directly (no pagination wrapper like BrickLink)

// Create single inventory
POST /v1/inventory/create
Body: { boid, color_id?, quantity, price, condition, external_id?, ... }
Response: { lot_id, boid, quantity, price, ... }

// Update single inventory (can use lot_id OR external_id)
POST /v1/inventory/update
Body: {
  lot_id: "...", // OR external_id: "..."
  absolute_quantity?: 10, // Set exact quantity
  relative_quantity?: 5,  // OR adjust by delta
  price?: 1.50,
  ...
}
Response: Updated inventory object

// Delete single inventory (can use lot_id OR external_id)
POST /v1/inventory/delete
Body: { lot_id: "..." } // OR { external_id: "..." }
Response: Success confirmation

// ⭐ Bulk batch endpoint (up to 50 requests)
POST /v1/bulk/batch
Body: {
  requests: [
    { endpoint: "inventory/create", request_method: "POST", params: [{...}] },
    { endpoint: "inventory/update", request_method: "POST", params: [{...}] },
    { endpoint: "inventory/delete", request_method: "POST", params: [{...}] },
  ]
}
Response: Array of responses matching request order
Note: Mixed operation types in single batch! Up to 50 requests per call.
```

**Critical API Differences from BrickLink:**

1. **Identifier Flexibility**: Can identify inventory by `lot_id` (BrickOwl's ID) OR `external_id` (our SKU)
   - BrickLink only supports inventory_id
   - Makes sync more resilient - can recover if we lose lot_id tracking
2. **Quantity Update Modes**: Explicit fields for absolute vs relative

   - `absolute_quantity`: Set exact quantity (e.g., 10)
   - `relative_quantity`: Adjust by delta (e.g., +5 or -5)
   - BrickLink requires "+5" string prefix format

3. **Response Format**: Direct arrays vs wrapped responses

   - BrickLink: `{ meta, data: [...] }`
   - BrickOwl: `[...]` directly

4. **Batch Endpoint**: Universal batch support

   - BrickLink: Only CREATE supports bulk
   - BrickOwl: ALL operations via batch endpoint

5. **Price Type**: Number vs string
   - BrickLink: `"1.2000"` (fixed-point string)
   - BrickOwl: `1.20` (number)

[Source: docs/external-documentation/api-brickowl/store-inventory.md; docs/external-documentation/api-brickowl/bulk-requests.md]

### Component Specifications

N/A - This story is backend-only (no frontend components).

### File Locations

**Backend:**

- **Auth Module**: `convex/brickowl/auth.ts` (new file - API key authentication helpers)
- **Store Client** (This Story): `convex/brickowl/storeClient.ts` (new file - uses auth helpers + DB rate limiting for store operations)
- **Store Mappers**: `convex/brickowl/storeMappers.ts` (new file - bidirectional BrickOwl store ↔ Convex mapping, handles inventory now + orders in Epic 4)
- **Marketplace Functions**: `convex/functions/marketplace.ts` (extend with `createBrickOwlStoreClient()` factory)
- **Marketplace Types**: `convex/marketplaces/types.ts` (extend if needed - reuse existing `StoreOperationResult` interface)
- **Schema**: `convex/schema.ts` (extend `inventoryItems` with `brickowlLotId` field)

[Source: docs/architecture/unified-project-structure.md]

### Technical Constraints

**API Key Authentication (User Credentials):**

- BrickOwl uses simple API key authentication (single key string)
- User API key stored encrypted; must decrypt at runtime using `decryptCredential()` from Story 3.1
- Pass API key in request headers: `Authorization: <api_key>`
- NEVER log API key values or Authorization headers in any logs/metrics
- Much simpler than BrickLink's OAuth 1.0a - no signature generation required

**Quantity Update Modes:**

- BrickOwl supports two update modes:
  - `absolute_quantity`: Set exact quantity (replaces current value)
  - `relative_quantity`: Add/subtract from current quantity (delta)
- Choose mode based on Story 3.4's sync strategy:
  - Use `absolute_quantity` when we know exact final quantity
  - Use `relative_quantity` for incremental adjustments
- Never send both fields in same request

**Dual Identifier System:**

- BrickOwl supports two ways to identify inventory:
  - `lot_id`: BrickOwl's internal identifier (returned on create)
  - `external_id`: Our SKU/reference (optional, we set this)
- **Recommended Strategy**: Always set `external_id_1 = sku` on create
  - Enables recovery if we lose lot_id tracking
  - Makes bulk operations more resilient
  - Simplifies debugging (can match by our SKU)

**Rate Limiting and Quota (Database-Backed):**

- **Architecture**: Database-backed quota tracking using `marketplaceRateLimits` Convex table (reuses Story 3.2 infrastructure)
- **Isolation**: BrickOwl quota completely separate from BrickLink quota; each business account has independent rate limit per provider
- **Enforcement**: Client layer performs pre-flight quota check and post-request recording via internal mutations/queries
- **Persistence**: Quota state persists across restarts and is shared across all Convex backend instances
- **Circuit Breaker**: Track consecutive failures; temporarily disable sync after 5 failures to prevent account suspension
- **Alerting**: Emit metric at 80% threshold; reset alert flag when window resets
- **HTTP 429 Handling**: Respect BrickOwl's `Retry-After` header if provided
- **Window Reset**: 24-hour rolling window with automatic reset logic in `incrementQuota` mutation
- **Capacity**: Research BrickOwl's published rate limits; default to conservative estimate (5,000/day like BrickLink) until confirmed

**Batch API Constraints:**

- Maximum 50 requests per batch call
- Can mix operation types (create, update, delete) in single batch
- Responses returned in same order as requests
- Each request can succeed or fail independently
- Batch itself can fail (network error, auth failure) - must retry entire batch

**Idempotency:**

- Generate request key (hash of payload) to dedupe bulk operations within same batch
- Support external idempotency keys via `options.idempotencyKey` - Story 3.4 will pass change log IDs
- NEVER auto-retry non-idempotent operations without idempotency key
- For batch operations, track which requests completed successfully to avoid re-executing on retry

**Structured Result Format (for Story 3.4 Integration):**

All CRUD operations return standardized result format for sync status tracking (reuses `StoreOperationResult` from Story 3.2):

```typescript
// Defined in convex/marketplaces/types.ts (from Story 3.2)
interface StoreOperationResult {
  success: boolean;
  brickowlLotId?: string; // BrickOwl uses string lot_id
  bricklinkInventoryId?: number; // BrickLink uses number inventory_id
  error?: {
    code: string; // e.g., "CONFLICT", "VALIDATION_ERROR", "RATE_LIMIT", "NOT_FOUND"
    message: string; // User-friendly error message
    details?: any; // Additional error context
  };
  marketplaceStatus?: string; // Provider's status field if available
  correlationId: string; // For tracing
}
```

[Source: docs/external-documentation/api-brickowl/store-inventory.md; docs/architecture/backend-architecture.md#actions-external-api-orchestration; docs/prd/epic-3-inventory-management.md#story-34; docs/stories/3.2.bricklink-client-inventory.story.md#technical-constraints]

### Error Handling

**Backend:**

- Use `ConvexError` for user-facing errors with helpful messages:
  - "BrickOwl credentials not configured" → guide to settings page
  - "BrickOwl API rate limit exceeded" → show retry-after time
  - "Invalid inventory data" → show which fields failed validation
- Use `normalizeApiError()` helper from `convex/lib/external/types.ts` for consistent error formatting
- Log all errors server-side with correlation ID but return safe messages to client
- Handle BrickOwl API errors gracefully:
  - HTTP 400 (Bad Request) → validation error, surface field-level details
  - HTTP 401 (Unauthorized) → API key invalid/expired, prompt user to update credentials
  - HTTP 404 (Not Found) → inventory lot doesn't exist on BrickOwl
  - HTTP 429 (Too Many Requests) → rate limit, show wait time
  - HTTP 500 (Server Error) → transient failure, retry with backoff

**Batch Operation Error Handling:**

- Track partial failures with detailed context: `{ batchIndex, requestIndex, request, error }`
- Return comprehensive result: `{ succeeded: number, failed: number, errors: Array<...> }`
- Allow caller to decide whether to retry failed requests or surface errors to user
- Log batch operation summary: `{ correlationId, totalRequests, succeeded, failed, durationMs }`
- For batch API failures (entire batch fails), retry entire batch with exponential backoff

[Source: docs/architecture/error-handling-strategy.md; docs/architecture/backend-architecture.md#function-template; docs/prd/epic-3-inventory-management.md#story-33]

### Security Considerations

**Credential Protection:**

- User marketplace credentials decrypted only server-side in actions (never exposed to client)
- Use `internal` actions for client creation - NEVER expose credential retrieval as public API
- RBAC enforcement: only owner role can trigger inventory sync operations
- All API requests log correlation ID but NEVER log API key values, auth headers, or sensitive data

**Tenant Isolation:**

- All operations require `businessAccountId` parameter
- Verify user belongs to business account before creating inventory client
- Rate limiting tracked per business account (separate quota per tenant)
- Never expose one tenant's BrickOwl data to another tenant

**Rate Limiting:**

- Respect BrickOwl's rate limits to avoid account suspension
- Implement circuit breaker: disable sync for account after repeated failures
- Surface clear error messages to users when rate limited (don't expose technical details)

**External ID Security:**

- When using `external_id_1`, ensure we don't leak sensitive information
- Use our internal SKU (safe to expose) not internal database IDs
- BrickOwl may expose `external_id` in public marketplace listings if `public_note` references it

[Source: docs/architecture/security-and-performance.md#security-requirements; docs/architecture/backend-architecture.md#authentication-and-authorization]

### Integration with Story 3.1 (Marketplace Credentials)

**Credential Retrieval and Client Factory Pattern:**

```typescript
// convex/functions/marketplace.ts
export const createBrickOwlStoreClient = async (
  ctx: ActionCtx,
  businessAccountId: Id<"businessAccounts">,
): Promise<BrickOwlStoreClient> => {
  // 1. Query marketplace credentials
  const credentials = await ctx.runQuery(internal.marketplace.getEncryptedCredentials, {
    businessAccountId,
    provider: "brickowl",
  });

  if (!credentials || !credentials.isActive) {
    throw new ConvexError(
      "BrickOwl credentials not configured. Please add your credentials in Settings.",
    );
  }

  // 2. Decrypt credentials (simpler than BrickLink - single API key)
  const apiKey = await decryptCredential(credentials.brickowlApiKey);

  // 3. Create and return client with ActionCtx for DB rate limiting
  return new BrickOwlStoreClient(
    { apiKey },
    businessAccountId,
    ctx, // ActionCtx enables DB-backed rate limiting
  );
};
```

**Why ActionCtx is Required:**

The store client needs `ActionCtx` to:

- Call `ctx.runQuery(internal.marketplace.getQuotaState, ...)` for pre-flight quota checks
- Call `ctx.runMutation(internal.marketplace.incrementQuota, ...)` for post-request recording
- Call `ctx.runMutation(internal.marketplace.recordFailure, ...)` for circuit breaker tracking

This is why the client is instantiated **inside an action**, not as a singleton.

[Source: docs/stories/3.1.user-marketplace-credentials-byok-on-settings.story.md#dev-notes; docs/architecture/backend-architecture.md#internal-functions-server-only-building-blocks]

### Integration with Story 3.4 (Orchestration Layer)

Story 3.4 will consume both BrickLink and BrickOwl clients using the **same interface** to sync inventory changes. The orchestration layer will determine which providers to sync based on user's configured credentials.

**Pattern 1: Multi-Provider Sync (Story 3.4 Core Capability)**

```typescript
// Story 3.4 sync action will sync to ALL configured providers
export const syncInventoryChange = internalAction({
  args: { changeId: v.id("inventoryChangeLog") },
  handler: async (ctx, { changeId }) => {
    // Get change details
    const change = await ctx.runQuery(internal.inventory.getChange, { changeId });

    // Determine which providers user has configured
    const providers = await getConfiguredProviders(change.businessAccountId);

    // Sync to each provider (parallel for efficiency)
    const syncResults = await Promise.all([
      providers.includes("bricklink") ? syncToBricklink(ctx, change) : null,
      providers.includes("brickowl") ? syncToBrickOwl(ctx, change) : null,
    ]);

    // Update sync status for each provider
    await ctx.runMutation(internal.inventory.updateMultiProviderSyncStatus, {
      changeId,
      bricklinkResult: syncResults[0],
      brickowlResult: syncResults[1],
      syncedAt: Date.now(),
    });
  },
});

async function syncToBrickOwl(ctx: ActionCtx, change: InventoryChange) {
  const client = await createBrickOwlStoreClient(ctx, change.businessAccountId);

  switch (change.changeType) {
    case "create":
      return await client.createInventory(change.newData, {
        idempotencyKey: `${change._id}-brickowl`,
      });
    case "update":
      return await client.updateInventory(change.brickowlLotId, change.delta, {
        idempotencyKey: `${change._id}-brickowl`,
      });
    case "delete":
      return await client.deleteInventory(change.brickowlLotId, {
        idempotencyKey: `${change._id}-brickowl`,
      });
  }
}
```

**Pattern 2: Efficient Bulk Initial Sync (Multi-Provider)**

```typescript
// Story 3.4 will support bulk initial sync to both providers
export const initialBulkSync = internalAction({
  args: { businessAccountId: v.id("businessAccounts") },
  handler: async (ctx, { businessAccountId }) => {
    const providers = await getConfiguredProviders(businessAccountId);
    const localInventory = await ctx.runQuery(internal.inventory.getAllInventory, {
      businessAccountId,
    });

    // Sync to each provider in parallel
    const results = await Promise.all([
      providers.includes("bricklink")
        ? syncBulkToBricklink(ctx, businessAccountId, localInventory)
        : null,
      providers.includes("brickowl")
        ? syncBulkToBrickOwl(ctx, businessAccountId, localInventory)
        : null,
    ]);

    return {
      bricklink: results[0],
      brickowl: results[1],
    };
  },
});

async function syncBulkToBrickOwl(
  ctx: ActionCtx,
  businessAccountId: Id<"businessAccounts">,
  inventory: InventoryItem[],
) {
  const client = await createBrickOwlStoreClient(ctx, businessAccountId);

  // Use BrickOwl's efficient batch API
  const payloads = inventory.map((item) => ({
    ...mapConvexToBrickOwlCreate(item),
    external_id: item.sku, // Set our SKU as external reference
  }));

  // BrickOwl: 1,000 items = 20 API calls (50 per batch)
  // vs BrickLink: 1,000 items = 10 API calls (100 per bulk create)
  const result = await client.bulkCreateInventories(payloads, {
    chunkSize: 50,
    onProgress: (p) => updateUI(p),
  });

  // Query back to get lot_ids (or use external_id for future lookups)
  const createdInventories = await client.getInventories();

  // Match and update Convex records with BrickOwl lot_ids
  await matchAndUpdateLotIds(ctx, businessAccountId, createdInventories);

  return result;
}
```

**Pattern 3: Provider-Specific Optimization (Story 3.4 Efficiency)**

```typescript
// Story 3.4 can optimize based on provider capabilities
export const syncPendingChanges = internalAction({
  args: { businessAccountId: v.id("businessAccounts") },
  handler: async (ctx, { businessAccountId }) => {
    const pendingChanges = await getPendingChanges(businessAccountId);
    const providers = await getConfiguredProviders(businessAccountId);

    // Optimize for each provider's strengths
    if (providers.includes("brickowl")) {
      // BrickOwl: Batch ALL operation types efficiently
      const brickowlStoreClient = await createBrickOwlStoreClient(ctx, businessAccountId);
      await syncChangesBatched(brickowlStoreClient, pendingChanges); // Mixed batch API
    }

    if (providers.includes("bricklink")) {
      // BrickLink: Separate handling for creates vs updates
      const bricklinkStoreClient = await createBricklinkStoreClient(ctx, businessAccountId);
      const creates = pendingChanges.filter((c) => c.type === "create");
      const updates = pendingChanges.filter((c) => c.type === "update");

      await bricklinkStoreClient.bulkCreateInventories(creates); // Efficient bulk
      await bricklinkStoreClient.bulkUpdateInventories(updates); // Sequential
    }
  },
});
```

**Key Requirements for Story 3.4 Integration:**

1. ✅ Both clients use same `StoreOperationResult` interface
2. ✅ Both clients support external idempotency keys (change IDs)
3. ✅ Both clients return structured results for sync status tracking
4. ✅ Both clients support rollback via inverse operations
5. ✅ Both clients provide detailed error responses for conflict handling
6. ✅ Both clients include correlation IDs for tracing through sync pipeline
7. ✅ Convex schema tracks both `bricklinkInventoryId` and `brickowlLotId` for multi-provider sync

**Performance Characteristics for Story 3.4:**

- **Initial Sync (all creates)**: BrickLink slightly faster (100/call vs 50/call)
- **Ongoing Sync (mixed ops)**: **BrickOwl dramatically faster** (50x for updates/deletes)
- **Rate Limit Conservation**: BrickOwl more efficient for update-heavy workloads
- **User Experience**: Both sync in background, multi-provider sync status visible in UI

[Source: docs/prd/epic-3-inventory-management.md#story-34; docs/architecture/backend-architecture.md#internal-functions-server-only-building-blocks; docs/stories/3.2.bricklink-client-inventory.story.md#integration-with-story-34-orchestration-layer]

## Change Log

| Date       | Version | Description                                                                                                                                                        | Author |
| ---------- | ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------ |
| 2025-10-09 | v1.0    | Initial draft of Story 3.3 following Story 3.2 pattern with BrickOwl-specific adaptations (API key auth, batch API, dual identifier system, parallel architecture) | Bob    |
| 2025-10-09 | v1.1    | Removed testing requirements (Task 8 and AC 3.3.7) - will be done in future story                                                                                  | Bob    |

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4.5

### Debug Log References

- Task 1: No debug logs - implementation completed without issues
- All linting checks passed

### Completion Notes List

**Task 1 - Authentication Module and Store Client (Completed)**

- Created `convex/brickowl/auth.ts` with pure, testable authentication helpers:
  - `validateApiKey()`: Validates BrickOwl API key format (20-128 alphanumeric chars)
  - `buildAuthHeaders()`: Constructs auth headers with API key
  - `generateRequestId()`: Creates unique correlation IDs for tracing
- Created `convex/brickowl/storeClient.ts` following BrickLink client pattern:
  - Constructor accepts user credentials + businessAccountId + ActionCtx
  - Database-backed rate limiting with pre-flight checks and post-request recording
  - Full CRUD operations: getInventories, getInventory, createInventory, updateInventory, deleteInventory
  - Bulk operations via native BrickOwl batch API (up to 50 requests per call)
  - Resiliency: exponential backoff, circuit breaker, retry logic
  - Idempotency support via request cache and external keys
  - Dry-run mode for rollback preview
  - Structured error handling with ConvexError
  - Comprehensive metrics and correlation ID logging
- Extended `convex/functions/marketplace.ts` with `createBrickOwlStoreClient()` factory
- Updated `convex/marketplaces/types.ts` to include both brickowlLotId and brickowlInventoryId fields
- All code follows existing patterns from BrickLink client (Story 3.2) for consistency

**Task 2 - Inventory Lot CRUD Operations (Completed - implemented in Task 1)**

- All CRUD operations already implemented in `BrickOwlStoreClient` class:
  - `getInventories(options?)`: List inventory with filtering (type, active_only, external_id_1, lot_id)
  - `getInventory(lotId)`: Fetch single lot by ID
  - `createInventory(payload, options?)`: Create lot with rollback data capture
  - `updateInventory(identifier, payload, options?)`: Update lot with dual identifier support
  - `deleteInventory(identifier, options?)`: Delete lot with dual identifier support
- CRITICAL requirement: Dual identifier system implemented via `useExternalId` option
  - Supports both `lot_id` (BrickOwl's ID) and `external_id` (our SKU)
  - Update/delete methods accept `useExternalId?: boolean` to switch identifier type
- CRITICAL requirement: Quantity update modes validated in `validateUpdatePayload()`
  - Supports `absolute_quantity` (set exact quantity)
  - Supports `relative_quantity` (adjust by delta)
  - Validation prevents using both modes simultaneously
- All operations return `StoreOperationResult` with proper error handling
- All operations map correctly to BrickOwl API endpoints

**Task 3 - Data Mappers for BrickOwl <-> Convex Schema (Completed)**

- Created `convex/brickowl/storeMappers.ts` with comprehensive bidirectional mapping functions:
  - `mapBrickOwlToConvexInventory()`: Transforms BrickOwl inventory response to Convex schema
    - Maps `lot_id` → `brickowlLotId`, `boid` → `partNumber`, `color_id` → `colorId`
    - Maps `quantity` → `quantityAvailable`, `price` (number) → `price`
    - Simplifies BrickOwl's detailed condition codes to "new"/"used"
    - Combines `personal_note` and `public_note` into `notes` field
    - Uses `external_id_1` as SKU reference for cross-marketplace tracking
    - Sets `for_sale` flag to determine status (available/reserved)
  - `mapConvexToBrickOwlCreate()`: Transforms Convex inventory to BrickOwl create payload
    - Maps in reverse with proper BrickOwl field names and formats
    - Uses SKU as `external_id` for future reference
    - Splits notes into `personal_note` and `public_note` if needed
    - Maps simplified condition back to BrickOwl codes
  - `mapConvexToBrickOwlUpdate()`: Transforms Convex inventory to BrickOwl update payload
    - Supports both `absolute_quantity` and `relative_quantity` modes
    - Calculates quantity delta for relative updates
    - Maps status to `for_sale` flag (0/1)
- Added helper functions:
  - `calculateQuantityDelta()`: Validates and calculates quantity changes
  - `mapBrickOwlConditionToConvex()`: Condition code mapping helper
  - `mapConvexConditionToBrickOwl()`: Reverse condition mapping helper
  - `buildExternalId()`: Generates external_id from Convex SKU
  - `parseTierPricing()`: Parses BrickOwl tier price format
  - `formatTierPricing()`: Formats tier prices for BrickOwl
- Added comprehensive validation functions:
  - `validateBrickOwlCreate()`: Validates required fields and enum values
  - `validateBrickOwlUpdate()`: Validates update payload (prevents both quantity modes)
- Extended `convex/schema.ts` to add `brickowlLotId` field:
  - Added `brickowlLotId: v.optional(v.string())` to inventoryItems table
  - Added index `by_brickowlLotId` for efficient lookups
- TypeScript types: All types imported from `storeClient.ts` (no duplication)
- Follows exact pattern from BrickLink mappers (Story 3.2) for consistency
- **REFACTORED**: Removed duplicate `ConvexInventoryItem` interface from both BrickLink and BrickOwl mappers
  - Now uses Convex's generated `Doc<"inventoryItems">` type directly
  - Eliminates code duplication and ensures type safety with actual schema
  - Single source of truth: schema is the source, mappers follow
  - Refactored both `convex/bricklink/storeMappers.ts` and `convex/brickowl/storeMappers.ts`

**Task 4 - Bulk Operations Using Native Batch API (Completed - implemented in Task 1)**

- All bulk operations already implemented in `BrickOwlStoreClient` class using BrickOwl's `/v1/bulk/batch` endpoint:
  - `bulkBatchOperations(requests[], options?)`: Core batch handler (lines 594-674)
    - Batches up to 50 requests per API call (BrickOwl maximum)
    - Supports mixed operation types (create, update, delete) in single batch
    - Each batch request specifies: `endpoint`, `request_method`, `params`
    - Returns responses in same order as requests
    - **Progress callback**: `onProgress({ completed, total, currentBatch, totalBatches })`
    - **Partial failure tracking**: Collects errors with full context (batchIndex, requestIndex, request, error)
    - **Idempotency support**: External keys via `options.idempotencyKey` for Story 3.4 integration
    - Returns comprehensive result: `{ succeeded, failed, total, errors, results }`
  - `bulkCreateInventories(payloads[], options?)`: Bulk create via batch API
    - Default chunk size: 50 items per batch
    - Efficiency: 50 creates = 1 API call (same as BrickLink bulk)
  - `bulkUpdateInventories(updates[], options?)`: Bulk update via batch API
    - Processes up to 50 updates per API call
    - Supports dual identifier system (`useExternalId` option)
    - **50x more efficient than BrickLink**: 50 updates = 1 call vs 50 sequential calls
  - `bulkDeleteInventories(identifiers[], options?)`: Bulk delete via batch API
    - Processes up to 50 deletes per API call
    - Supports dual identifier system (`useExternalId` option)
    - **50x more efficient than BrickLink**: 50 deletes = 1 call vs 50 sequential calls
- Rate limit optimization: Bulk batch of 50 items = 1 API call for any operation type
- Each operation returns `StoreOperationResult` with `brickowlLotId` for sync status tracking
- Handles both individual request failures and entire batch failures gracefully
- **BrickOwl's Universal Batch API Advantage**: Unlike BrickLink (only CREATE supports bulk), BrickOwl's batch endpoint supports ALL operations, making it dramatically more efficient for update-heavy workloads

**Task 5 - Database-Backed Rate Limiting (Completed)**

- Database-backed rate limiting fully implemented in `BrickOwlStoreClient.request()`:
  - **Conservative single quota**: 200 requests/minute for all BrickOwl requests
    - Uses stricter bulk endpoint limit (200/min) for all endpoints
    - Simpler implementation - single quota pool for all BrickOwl operations
  - **Pre-flight quota check** (lines 257-261): Calls `getQuotaState(businessAccountId, "brickowl")` before every request
  - **Circuit breaker check** (lines 263-269): Prevents requests when circuit is open, throws error with `retryAfterMs`
  - **Quota exceeded handling** (lines 271-281): Throws `ConvexError` with `retryAfterMs` for Story 3.4 retry scheduling
  - **Post-request quota recording** (lines 317-321): Calls `incrementQuota(businessAccountId, "brickowl")` after successful request
  - **80% alert threshold** (lines 283-293): Emits `external.brickowl.store.quota.alert` metric when alertEmitted flag is set
- Reuses existing `marketplaceRateLimits` table from Story 3.2:
  - Table already supports multi-provider via `provider` field
  - BrickOwl uses `provider: "brickowl"` for complete isolation from BrickLink quota
  - Each business account has independent quota per provider
- Updated internal functions in `convex/functions/marketplace.ts`:
  - `getQuotaState()`: Already supports "brickowl" provider
  - `incrementQuota()`: Provider-specific initialization with correct capacity and window:
    - BrickLink: 5,000 requests/24 hours
    - BrickOwl: 200 requests/1 minute (conservative - uses bulk limit for all)
  - `recordFailure()`: Already supports "brickowl" provider
  - `resetFailures()`: Already supports "brickowl" provider
- **BrickOwl's Actual Rate Limits** (from official API documentation):
  - Regular endpoints: 600 requests per minute
  - Bulk/batch endpoints: 200 requests per minute
  - **Implementation uses 200/min for all requests** (conservative approach)
  - Much faster window reset than BrickLink (1 minute vs 24 hours)
- **Tenant isolation**: All quota tracking is per business account
  - BrickOwl quota completely separate from BrickLink quota
  - User can hit both providers' limits independently
  - Circuit breaker is per-provider per-account

**Task 6 - Resiliency Patterns (Completed)**

- Exponential backoff retry logic implemented in `requestWithRetry()` method (lines 289-349):
  - **Retry policy**: `{ maxRetries: 5, initialDelayMs: 1000, maxDelayMs: 32000, backoffMultiplier: 2 }`
  - **Exponential backoff**: Starts at 1s, doubles each retry (1s → 2s → 4s → 8s → 16s → 32s max)
  - **Max retries**: 5 attempts before giving up
  - **Retry logic wrapper**: All CRUD methods now use `requestWithRetry()` instead of direct `request()`
- Transient failure detection (lines 267-287):
  - **HTTP 5xx errors**: Automatically retried with exponential backoff
  - **Network errors**: TypeError with "fetch" detected and retried
  - **Non-retryable errors**: 4xx client errors (except 429) fail immediately
- HTTP 429 rate limit handling (lines 486-500):
  - Extracts `Retry-After` header from BrickOwl response
  - Defaults to 60s if header not provided
  - Emits `external.brickowl.store.throttle` metric with retry time
  - Respectful backoff honors BrickOwl's requested delay
- Circuit breaker pattern (already implemented, enhanced):
  - Pre-flight check in `request()` method (lines 374-380)
  - Records failures via `recordFailure()` mutation for 5xx errors and network errors
  - Opens circuit after 5 consecutive failures
  - 5-minute cooldown period (`circuitBreakerOpenUntil` field)
  - Prevents account suspension by blocking requests during cooldown
- **CRITICAL idempotency safety** (lines 298-300, 320-323):
  - Only retries operations marked as `isIdempotent: true`
  - GET operations: Always safe to retry
  - POST with idempotencyKey: Safe to retry (deduplication via cache)
  - POST without idempotencyKey: NEVER auto-retry (could cause duplicates)
  - All CRUD methods updated to specify `isIdempotent` flag
- Enhanced error tracking:
  - HTTP status code attached to ConvexError for retry logic
  - Failures recorded for circuit breaker on 5xx and network errors
  - Retry attempts tracked via `external.brickowl.store.retry` metric

**Task 7 - Structured Logging and Metrics (Completed)**

- Comprehensive metrics tracking using `recordMetric()` helper:
  - ✅ `external.brickowl.store.request`: Request initiated (operation, method, businessAccountId, correlationId)
  - ✅ `external.brickowl.store.success`: Request succeeded (operation, businessAccountId, durationMs, correlationId)
  - ✅ `external.brickowl.store.error`: Request failed (operation, businessAccountId, durationMs, correlationId, errorMessage)
  - ✅ `external.brickowl.store.retry`: Retry attempt (retryCount, delayMs, correlationId)
  - ✅ `external.brickowl.store.quota_exceeded`: Quota limit reached (businessAccountId, correlationId)
  - ✅ `external.brickowl.store.quota.alert`: 80% threshold reached (businessAccountId, requestCount, capacity, percentage)
  - ✅ `external.brickowl.store.throttle`: HTTP 429 rate limit (correlationId, retryAfterMs)
  - ✅ `external.brickowl.store.cache_hit`: Idempotency cache hit (operation, correlationId)
  - ✅ `external.brickowl.store.bulk.start`: Bulk operation started (itemCount, totalBatches, businessAccountId)
  - ✅ `external.brickowl.store.bulk.progress`: Batch progress (completed, total, currentBatch, totalBatches, businessAccountId, correlationId)
  - ✅ `external.brickowl.store.bulk.complete`: Bulk operation finished (itemCount, succeeded, failed, businessAccountId)
- Correlation ID generation and propagation:
  - ✅ `generateRequestId()` from `auth.ts` creates unique IDs (format: "bo-{timestamp}-{random}")
  - ✅ Correlation IDs passed through entire request chain
  - ✅ All metrics include correlationId for distributed tracing
- Request metadata logged:
  - ✅ operation (endpoint path)
  - ✅ method (GET/POST)
  - ✅ businessAccountId (tenant isolation)
  - ✅ durationMs (performance tracking)
  - ✅ itemCount (bulk operations)
  - ✅ retryCount (resilience tracking)
- Error details logged:
  - ✅ correlationId (tracing)
  - ✅ operation (which endpoint failed)
  - ✅ errorMessage (user-friendly message)
  - ✅ httpStatus (attached to ConvexError for retry logic)
  - ✅ businessAccountId (tenant context)
- **Security compliance**:
  - ✅ NEVER logs API key values or credentials
  - ✅ NEVER logs Authorization headers
  - ✅ Only logs safe metadata (operation names, IDs, durations, counts)
  - ✅ Uses `normalizeApiError()` for consistent, safe error formatting
- Bulk operation progress tracking:
  - ✅ Start metric with total itemCount and batch count
  - ✅ Progress metric after each batch with completion status
  - ✅ Complete metric with final succeeded/failed counts

**Task 8 - Client Factory with Credential Decryption (Completed - implemented in Task 1)**

- Client factory already fully implemented in `convex/functions/marketplace.ts` (lines 774-798):
  - ✅ `createBrickOwlStoreClient(ctx, businessAccountId)` exported function
  - ✅ Queries `marketplaceCredentials` table via `getEncryptedCredentials()` internal query
  - ✅ Validates credentials exist: Throws user-friendly error if not found
    - Error message: "BrickOwl credentials not configured. Please add your credentials in Settings."
    - Includes error code: "CREDENTIALS_NOT_FOUND"
  - ✅ Decrypts credentials using `decryptCredential()` from Story 3.1
    - Only decrypts `brickowlApiKey` field (simpler than BrickLink's 4-field OAuth)
  - ✅ Instantiates `BrickOwlStoreClient` with three parameters:
    - `credentials`: Decrypted API key object
    - `businessAccountId`: Tenant context for quota tracking
    - `ctx`: ActionCtx for database-backed rate limiting
  - ✅ Returns ready client instance for inventory operations (orders in Epic 4)
- Integration with Story 3.1 credential storage:
  - ✅ Uses encrypted credentials from `marketplaceCredentials` table
  - ✅ Filters by `provider: "brickowl"`
  - ✅ Server-side decryption only (never exposed to client)
- **RBAC enforcement**: Owner role check in Story 3.4 orchestration layer (not here)
- **Constructor signature verified**: `new BrickOwlStoreClient(credentials, businessAccountId, ctx)`
  - ActionCtx enables `ctx.runQuery()` and `ctx.runMutation()` for quota tracking
  - Follows exact same pattern as BrickLink client factory

**Task 9 - Rollback and Compensating Operations Support (Completed - implemented in Task 1)**

- Rollback patterns fully documented in `convex/brickowl/storeClient.ts` file header (lines 5-37):
  - ✅ CREATE rollback: `createInventory()` → `deleteInventory(brickowlLotId)`
  - ✅ UPDATE rollback: `updateInventory()` → `updateInventory()` with previous values
    - Reverse quantity delta: relative_quantity: 5 becomes -5
  - ✅ DELETE rollback: `deleteInventory()` → `createInventory(originalPayload)`
    - Note: New inventory will have different lot_id
- All operation responses include rollbackData for Story 3.4:
  - ✅ **createInventory** response (lines 626-628):
    - Returns `rollbackData.originalPayload` with complete create payload
    - Story 3.4 can call `deleteInventory(brickowlLotId)` to reverse
  - ✅ **updateInventory** response (lines 684-687):
    - Returns `rollbackData.previousQuantity`, `previousPrice`, `previousNotes`
    - Story 3.4 can construct compensating update with previous values
    - Quantity delta reversal: +5 becomes -5
  - ✅ **deleteInventory** response (lines 739-741):
    - Returns `rollbackData.originalPayload` with full BrickOwlInventoryResponse
    - Story 3.4 can recreate inventory (will have new lot_id)
- Dry-run mode fully supported in all CRUD operations:
  - ✅ `createInventory(payload, { dryRun: true })` (lines 602-608)
    - Validates payload via `validateCreatePayload()`
    - Returns mock success response without API call
  - ✅ `updateInventory(id, payload, { dryRun: true })` (lines 651-658)
    - Validates payload via `validateUpdatePayload()`
    - Returns mock success response without API call
  - ✅ `deleteInventory(id, { dryRun: true })` (lines 710-717)
    - Returns mock success response without API call
  - ✅ Enables Story 3.4 rollback preview: "What would happen if I reversed this change?"
- `StoreOperationResult` interface already includes rollbackData field:
  - ✅ Reuses existing interface from `convex/marketplaces/types.ts` (Story 3.2)
  - ✅ No BrickOwl-specific types needed - interface is provider-agnostic
  - ✅ Includes `brickowlLotId` field for BrickOwl operations
- Story 3.4 integration ready:
  - ✅ All operations return structured results with rollback data
  - ✅ Dry-run mode enables rollback preview without side effects
  - ✅ Compensating operations can be constructed from rollbackData
  - ✅ Correlation IDs enable tracing through rollback chain

### File List

**Created:**

- `convex/brickowl/auth.ts`
- `convex/brickowl/storeClient.ts`
- `convex/brickowl/storeMappers.ts`

**Modified:**

- `convex/functions/marketplace.ts` (added BrickOwl client factory; updated rate limiting for BrickOwl)
- `convex/marketplaces/types.ts` (added brickowlLotId field)
- `convex/schema.ts` (added brickowlLotId field and index to inventoryItems table)
- `convex/bricklink/storeMappers.ts` (refactored to use Doc<"inventoryItems"> instead of duplicate interface)
- `convex/brickowl/storeMappers.ts` (refactored to use Doc<"inventoryItems"> instead of duplicate interface)
- `convex/brickowl/storeClient.ts` (added rate limiting, resiliency, logging, rollback support)
- `convex/lib/external/env.ts` (fixed test environment support - allows placeholder values during module load)

## QA Results

_(Populated by QA Agent after implementation)_
