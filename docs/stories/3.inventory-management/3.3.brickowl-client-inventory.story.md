# Story 3.3: BrickOwl Store Client (Inventory Lots + Mappers)

## Status

Draft

## Story

**As a** system,
**I want** a robust BrickOwl client with inventory lot CRUD and data mappers,
**so that** we can synchronize our users' store inventory to/from BrickOwl in a reliable and maintainable way.

## Acceptance Criteria

1. **3.3.1:** Implement a typed BrickOwl client that authenticates with user-provided credentials (API key format) and supports required authentication headers.
2. **3.3.2:** Provide CRUD operations for store inventory lots: create lot, read/get lot(s), update lot, delete lot; include list/pagination support where the API allows.
3. **3.3.3:** Implement data mappers to transform BrickOwl request/response payloads into our Convex `inventories` schema shapes and back (including fields like part identifier, condition, quantity, price, location, remarks/notes, status).
4. **3.3.4:** Support bulk operations using BrickOwl's native bulk batch endpoint (up to 50 requests per batch); provide chunked/sequenced operations with progress and partial-failure reporting.
5. **3.3.5:** Add resiliency: handle rate limits and transient failures via exponential backoff, retry policies, and idempotency (dedupe by request keys).
6. **3.3.6:** Provide structured logging (with correlation IDs) and metrics around request counts, latency, errors, and throttle events; no secrets in logs.
7. **3.3.7:** Include unit tests using HTTP mocking to validate authentication, mapping correctness, error handling, and rate-limit behavior.

## Tasks / Subtasks

- [ ] Task 1: Create authentication module and specialized inventory client (AC: 3.3.1)

  - [ ] **Create Shared Auth Module**: Create `convex/brickowl/auth.ts` module with reusable API key authentication functions:
    - Create `buildAuthHeaders(apiKey)` helper for constructing authentication headers
    - Create `validateApiKey(apiKey)` helper for API key format validation
    - Add `generateRequestId()` helper for unique request identification
    - CRITICAL: Make functions pure and testable (accept API key as parameter, not from env)
  - [ ] **Create New Store Client** (`convex/brickowl/storeClient.ts`):
    - New class that accepts user credentials and `businessAccountId` as constructor arguments
    - Use shared auth functions from `auth.ts` for authentication
    - Implement database-backed rate limiting (pre-flight check + post-request recording)
    - Implement store inventory CRUD methods
    - CRITICAL: Use user credentials passed to constructor (NOT env variables)
    - NOTE: Named "Store" not "Inventory" - will also handle orders in Epic 4
  - [ ] Add validation to ensure API key is properly formatted before making requests
  - [ ] [Source: docs/architecture/backend-architecture.md#actions-external-api-orchestration; docs/external-documentation/api-brickowl/store-inventory.md; docs/stories/3.1.user-marketplace-credentials-byok-on-settings.story.md#dev-notes]

- [ ] Task 2: Implement inventory lot CRUD operations (AC: 3.3.2)

  - [ ] Implement `getInventories(options?: { type?, active_only?, external_id?, lot_id? })` method for listing inventory lots with filtering support (maps to `GET /v1/inventory/list`)
  - [ ] Implement `getInventory(lotId: string)` method for fetching single inventory lot (maps to `GET /v1/inventory/list` with lot_id filter)
  - [ ] Implement `createInventory(payload)` method for creating single inventory lot (maps to `POST /v1/inventory/create`)
  - [ ] Implement `updateInventory(lotId: string, payload)` method for updating single inventory lot (maps to `POST /v1/inventory/update`)
  - [ ] Implement `deleteInventory(lotId: string)` method for deleting single inventory lot (maps to `POST /v1/inventory/delete`)
  - [ ] CRITICAL: Support both absolute_quantity and relative_quantity update modes per BrickOwl API requirements
  - [ ] CRITICAL: Handle external_id (our SKU/reference) and lot_id (BrickOwl's ID) as dual identifier system
  - [ ] [Source: docs/external-documentation/api-brickowl/store-inventory.md; docs/prd/epic-3-inventory-management.md#story-33]

- [ ] Task 3: Implement data mappers for BrickOwl <-> Convex schema (AC: 3.3.3)

  - [ ] Create `convex/brickowl/storeMappers.ts` with bidirectional mapper functions for store data (inventory now, orders in Epic 4)
  - [ ] Implement `mapBrickOwlToConvexInventory(brickowlInventory)` to transform BrickOwl inventory response to our `inventoryItems` schema (map: `lot_id` → `brickowlLotId`, `boid` → `partNumber`, `color_id` → `colorId`, `quantity` → `quantityAvailable`, `condition` → `condition`, `price` → `price`, `personal_note`/`public_note` → `notes`, `external_id` → external reference tracking)
  - [ ] Implement `mapConvexToBrickOwlInventory(convexInventory)` to transform our inventory to BrickOwl create/update payload (reverse mapping with proper field names and format)
  - [ ] Handle optional fields gracefully (e.g., BrickOwl's tier_price, bulk_qty, sale_percent)
  - [ ] Include TypeScript types for BrickOwl inventory request/response shapes based on API documentation
  - [ ] Add validation for required fields and proper enum values (condition codes, item type)
  - [ ] [Source: docs/external-documentation/api-brickowl/store-inventory.md; docs/architecture/data-models.md#inventoryitem; docs/architecture/backend-architecture.md#function-template]

- [ ] Task 4: Implement bulk operations using native batch API (AC: 3.3.4)

  - [ ] **BULK OPERATIONS (Native BrickOwl Batch API - Efficient)**:
    - Implement `bulkBatchOperations(requests[], options?: { chunkSize?, onProgress? })` that uses BrickOwl's `/v1/bulk/batch` endpoint
    - Batch up to 50 requests per API call (BrickOwl maximum)
    - Support mixed operation types in single batch (create, update, delete)
    - Each batch request specifies: `endpoint`, `request_method` (GET/POST), `params`
    - Returns array of responses matching request order
  - [ ] **BULK CREATE**:
    - Implement `bulkCreateInventories(payloads[], options?)` that chunks into batches and calls native batch API
    - Default chunk size: 50 items per batch (BrickOwl limit)
    - More efficient than BrickLink: 50 creates = 1 API call
  - [ ] **BULK UPDATE**:
    - Implement `bulkUpdateInventories(updates[], options?)` that sequences individual updates via batch API
    - Use batch endpoint to process up to 50 updates per call
    - More efficient than BrickLink sequential: 50 updates = 1 API call vs 50 calls
  - [ ] **BULK DELETE**:
    - Implement `bulkDeleteInventories(ids[], options?)` that sequences individual deletes via batch API
    - Use batch endpoint for efficiency: 50 deletes = 1 API call
  - [ ] **Common Bulk Features**:
    - Add progress callback: `onProgress({ completed: number, total: number, currentBatch: number, totalBatches: number })`
    - Track partial failures: collect all errors with context (batch index, request index, error details) and return comprehensive result: `{ succeeded: number, failed: number, errors: Array<{ batchIndex, requestIndex, request, error }> }`
    - Add idempotency: dedupe requests by generating stable request key (hash of payload) and skip duplicate operations within same bulk batch
    - CRITICAL: Support external idempotency keys via `options.idempotencyKey?` parameter - Story 3.4 will pass change log IDs for deduplication across retry attempts
    - Return structured result for each operation: `{ success: boolean, brickowlLotId?: string, error?: { code, message, details }, marketplaceStatus?: string }` to support Story 3.4 sync status tracking
  - [ ] **Rate Limit Optimization**: Track API calls consumed: bulk batch of 50 items = 1 call for any operation type
  - [ ] [Source: docs/external-documentation/api-brickowl/store-inventory.md; docs/external-documentation/api-brickowl/bulk-requests.md; docs/prd/epic-3-inventory-management.md#story-33; docs/prd/epic-3-inventory-management.md#story-34; docs/architecture/backend-architecture.md#actions-external-api-orchestration]

- [ ] Task 5: Database-backed rate limiting (AC: 3.3.5 - per-user quota tracking)

  - [ ] Reuse existing `marketplaceRateLimits` table from Story 3.2 (already supports multi-provider via provider field)
  - [ ] Extend internal queries in `convex/functions/marketplace.ts`: `getQuotaState(businessAccountId, "brickowl")` returns current quota usage
  - [ ] Extend internal mutation: `incrementQuota(businessAccountId, "brickowl")` atomically increments request count with window reset logic
  - [ ] In `BrickOwlStoreClient.request()`: implement pre-flight quota check by calling `getQuotaState()` before making API request
  - [ ] If quota exceeded, throw `ConvexError` with code `RATE_LIMIT_EXCEEDED`, include `retryAfterMs` for Story 3.4 retry scheduling
  - [ ] In `BrickOwlStoreClient.request()`: implement post-request quota recording by calling `incrementQuota()` after successful API call
  - [ ] Add quota alert at 80% threshold: emit metric `external.brickowl.store.quota.alert` when business account reaches warning level
  - [ ] CRITICAL: Quota tracking is per business account (tenant-isolated) and separate from BrickLink quota
  - [ ] CRITICAL: Set appropriate capacity for BrickOwl (research their documented rate limits, default to conservative estimate if not published)
  - [ ] [Source: docs/architecture/backend-architecture.md#actions-external-api-orchestration; docs/prd/epic-3-inventory-management.md#story-33; docs/stories/3.2.bricklink-client-inventory.story.md#database-backed-rate-limiting-architecture]

- [ ] Task 6: Resiliency patterns (AC: 3.3.5)

  - [ ] Implement exponential backoff for transient failures (HTTP 5xx, network errors): start with 1s delay, double each retry up to max 32s, max 5 retries
  - [ ] Handle BrickOwl HTTP 429 responses: extract `Retry-After` header if available, implement respectful backoff
  - [ ] Implement circuit breaker pattern: if 5 consecutive failures for a business account, temporarily disable that account's BrickOwl sync for 5 minutes (track in `marketplaceRateLimits` table with `circuitBreakerOpenUntil` field)
  - [ ] Add retry policy configuration: `{ maxRetries: 5, initialDelayMs: 1000, maxDelayMs: 32000, backoffMultiplier: 2 }`
  - [ ] CRITICAL: Never retry non-idempotent operations (POST create without idempotency key) automatically; only retry safe operations (GET, idempotent POST/PUT/DELETE)
  - [ ] [Source: docs/architecture/backend-architecture.md#actions-external-api-orchestration; docs/architecture/coding-standards.md#critical-rules]

- [ ] Task 7: Structured logging and metrics (AC: 3.3.6)

  - [ ] Add correlation ID generation for all operations: `crypto.randomUUID()` passed through entire request chain
  - [ ] Use existing `recordMetric()` helper from `convex/lib/external/metrics.ts` for tracking: `external.brickowl.store.request`, `external.brickowl.store.success`, `external.brickowl.store.error`, `external.brickowl.store.retry`, `external.brickowl.store.quota`
  - [ ] Log request metadata: `{ correlationId, operation, businessAccountId, itemCount (for bulk), durationMs, retryCount }`
  - [ ] Log error details: `{ correlationId, operation, errorCode, errorMessage, httpStatus, businessAccountId }` - NEVER log API key values or auth headers
  - [ ] Add metric for bulk operation progress: `external.brickowl.store.bulk.progress { completed, total, batchIndex }`
  - [ ] Reuse existing `normalizeApiError()` from `convex/lib/external/types.ts` for consistent error formatting
  - [ ] [Source: docs/architecture/backend-architecture.md#convex-function-patterns-and-best-practices; docs/prd/epic-3-inventory-management.md#story-33]

- [ ] Task 8: Unit tests with HTTP mocking (AC: 3.3.7)

  - [ ] Create `__tests__/backend/brickowl-store-client.test.ts` using Vitest and HTTP mocking
  - [ ] Test API key authentication: verify request headers include correct authentication
  - [ ] Test CRUD operations: mock BrickOwl API responses for each operation (get, list, create, update, delete), verify request payloads and response parsing
  - [ ] Test data mapper bidirectional conversion: verify BrickOwl → Convex and Convex → BrickOwl transformations preserve all fields correctly
  - [ ] Test bulk batch operations: verify batch request formatting, response parsing, progress callbacks, partial failure handling
  - [ ] Test database-backed rate limiting:
    - Mock quota queries/mutations
    - Verify pre-flight quota check prevents API call when quota exceeded
    - Verify post-request quota recording increments counter
    - Test window reset logic (24-hour rollover)
    - Test alert threshold triggers (80% capacity)
    - Test circuit breaker opens after 5 consecutive failures
    - Verify `RATE_LIMIT_EXCEEDED` error includes `retryAfterMs` for Story 3.4 scheduling
  - [ ] Test exponential backoff: simulate transient failures, verify retry delays follow expected backoff pattern
  - [ ] Test error handling: simulate various HTTP error codes (400, 401, 403, 404, 429, 500), verify proper error normalization and logging
  - [ ] Use `BrickOwlStoreClient.createForTesting()` factory with mocked credentials for deterministic tests
  - [ ] [Source: docs/architecture/testing-strategy.md#backend-tests; docs/architecture/coding-standards.md#testing-standards]

- [ ] Task 9: Client factory with credential decryption (Story 3.1 integration)

  - [ ] Extend internal action `marketplace.createBrickOwlStoreClient(businessAccountId)` in `convex/functions/marketplace.ts`
  - [ ] Action queries `marketplaceCredentials` table for the business account's BrickOwl credentials (provider: "brickowl")
  - [ ] If no credentials found or inactive, throw `ConvexError` with user-friendly message: "BrickOwl credentials not configured. Please add your credentials in Settings."
  - [ ] Decrypt credentials using `decryptCredential()` from `convex/lib/encryption.ts`
  - [ ] Instantiate `BrickOwlStoreClient` with: decrypted credentials, businessAccountId, AND ActionCtx (`ctx`) - client needs ctx for DB rate limiting
  - [ ] Return client instance ready for store operations (inventory now, orders in Epic 4)
  - [ ] Add RBAC check: only owner role can trigger store sync operations (check in Story 3.4 orchestration layer, not here)
  - [ ] CRITICAL: Client constructor signature is `new BrickOwlStoreClient(credentials, businessAccountId, ctx)` - ctx enables database queries/mutations for quota tracking
  - [ ] [Source: docs/stories/3.1.user-marketplace-credentials-byok-on-settings.story.md#dev-notes; docs/architecture/backend-architecture.md#authentication-and-authorization; docs/architecture/backend-architecture.md#internal-functions-server-only-building-blocks]

- [ ] Task 10: Rollback and compensating operations support (Story 3.4 rollback capability)

  - [ ] All CRUD operations already support rollback pattern: `createInventory` → `deleteInventory`, `deleteInventory` → `createInventory` (with same payload), `updateInventory` → `updateInventory` (with previous values)
  - [ ] Ensure all operation responses include enough information for Story 3.4 to construct compensating operations: `{ brickowlLotId, previousQuantity?, previousPrice?, etc. }`
  - [ ] Document rollback patterns in Dev Notes: for each operation type, specify the inverse operation and required data
  - [ ] Add support for "dry-run" mode via `options.dryRun?: boolean` - validates operation without executing (for Story 3.4 rollback preview)
  - [ ] Extend `convex/marketplaces/types.ts` with BrickOwl-specific types if needed (reuse `StoreOperationResult` interface)
  - [ ] [Source: docs/prd/epic-3-inventory-management.md#story-34-ac-347; docs/architecture/backend-architecture.md#actions-external-api-orchestration; docs/stories/3.2.bricklink-client-inventory.story.md#integration-with-story-34-orchestration-layer]

## Dev Notes

### Quick Reference: Parallel Architecture with BrickLink

**BrickOwl Store Client** follows the exact same architectural pattern as BrickLink Store Client from Story 3.2:

| Aspect                 | BrickLink Client (Story 3.2)             | BrickOwl Client (Story 3.3)             |
| ---------------------- | ---------------------------------------- | --------------------------------------- |
| **Authentication**     | OAuth 1.0a (4 credentials)               | API Key (single key)                    |
| **Auth Module**        | `bricklink/oauth.ts`                     | `brickowl/auth.ts`                      |
| **Store Client**       | `bricklink/storeClient.ts`               | `brickowl/storeClient.ts`               |
| **Store Mappers**      | `bricklink/storeMappers.ts`              | `brickowl/storeMappers.ts`              |
| **Rate Limiting**      | Database-backed (per-tenant)             | Database-backed (per-tenant)            |
| **Quota Pool**         | Independent per business account         | Independent per business account        |
| **Methods**            | Store operations (inventory + orders)    | Store operations (inventory + orders)   |
| **Instantiation**      | Factory per request (user-specific)      | Factory per request (user-specific)     |
| **Tenant Context**     | Requires `businessAccountId`             | Requires `businessAccountId`            |
| **Bulk Support**       | Native bulk CREATE only (100 items/call) | **Native batch API (50 requests/call)** |
| **Credentials Source** | User database (BYOK)                     | User database (BYOK)                    |

**Key Architectural Advantage: BrickOwl's Batch API**

Unlike BrickLink which only supports native bulk for CREATE operations, BrickOwl provides a universal batch endpoint (`/v1/bulk/batch`) that accepts up to 50 requests of ANY type in a single API call. This makes BrickOwl significantly more efficient for UPDATE and DELETE operations.

**Efficiency Comparison:**

| Operation  | BrickLink (Story 3.2)     | BrickOwl (Story 3.3)            |
| ---------- | ------------------------- | ------------------------------- |
| 50 CREATEs | 1 API call (native bulk)  | 1 API call (via batch)          |
| 50 UPDATEs | 50 API calls (sequential) | **1 API call (via batch)** ⭐   |
| 50 DELETEs | 50 API calls (sequential) | **1 API call (via batch)** ⭐   |
| Mixed ops  | Multiple calls            | **1 API call (mixed batch)** ⭐ |

This architectural difference means BrickOwl sync will be **significantly faster** for update-heavy workloads and consume far less quota.

### Previous Story Insights

- **Story 3.1 (User Marketplace Credentials)**: Established secure credential storage with encryption at rest and test connection functionality. BrickOwl uses simpler API key authentication compared to BrickLink's OAuth 1.0a, making the authentication flow more straightforward.
- **Story 3.2 (BrickLink Store Client)**: Set the architectural pattern for marketplace store clients. This story replicates that pattern exactly: separate specialized client, database-backed rate limiting, comprehensive resiliency, structured logging, and Story 3.4 integration support.
- **Architectural Pattern Reuse**: By following Story 3.2's pattern exactly, we maintain consistency across marketplace integrations and enable Story 3.4's orchestration layer to work with both providers using the same interface.
- [Source: docs/stories/3.1.user-marketplace-credentials-byok-on-settings.story.md; docs/stories/3.2.bricklink-client-inventory.story.md]

### CRITICAL: Parallel Client Architecture (Consistent with Story 3.2)

**Directory Structure (After Story 3.3):**

```text
convex/
├── bricklink/
│   ├── bricklinkClient.ts     # Catalog client (unchanged)
│   ├── bricklinkMappers.ts    # Catalog mappers (unchanged)
│   ├── dataRefresher.ts       # Catalog refresh jobs (unchanged)
│   ├── oauth.ts               # OAuth 1.0a helpers (Story 3.2)
│   ├── storeClient.ts         # Store client (Story 3.2)
│   └── storeMappers.ts        # Store mappers (Story 3.2)
│
├── brickowl/                  # NEW FOLDER - Story 3.3
│   ├── auth.ts                # NEW - API key authentication helpers
│   ├── storeClient.ts         # NEW - Store client (inventory + future orders)
│   └── storeMappers.ts        # NEW - Store data mappers
│
├── marketplaces/
│   └── types.ts               # Shared TypeScript interfaces (Story 3.2, extended in 3.3)
│
├── functions/
│   ├── marketplace.ts         # EXTEND - Add createBrickOwlStoreClient() factory
│   └── inventory.ts           # Business logic (unchanged)
```

**Naming Consistency:**

- Both use "Store" not "Inventory" - encompasses inventory + orders + settings
- Both follow factory pattern via `createXStoreClient(businessAccountId)`
- Both use database-backed rate limiting via `marketplaceRateLimits` table
- Both return `StoreOperationResult` for Story 3.4 integration

**Never Mix Credentials:**

```typescript
// ❌ WRONG - Using wrong provider's client
const bricklinkClient = await createBricklinkStoreClient(ctx, businessAccountId);
await bricklinkClient.createInventory(...); // This goes to BrickLink!

const brickowlClient = await createBrickOwlStoreClient(ctx, businessAccountId);
await brickowlClient.createInventory(...); // This goes to BrickOwl!
// They are NOT interchangeable!

// ✅ CORRECT - Use appropriate client for each provider
// Story 3.4 will determine which providers to sync based on user's configured credentials
const providers = await getConfiguredProviders(businessAccountId);

if (providers.includes("bricklink")) {
  const bricklinkClient = await createBricklinkStoreClient(ctx, businessAccountId);
  await syncToBricklink(bricklinkClient, changes);
}

if (providers.includes("brickowl")) {
  const brickowlClient = await createBrickOwlStoreClient(ctx, businessAccountId);
  await syncToBrickOwl(brickowlClient, changes);
}
```

[Source: docs/architecture/backend-architecture.md#internal-functions-server-only-building-blocks; docs/stories/3.2.bricklink-client-inventory.story.md#critical-separate-specialized-clients-architecture]

### Database-Backed Rate Limiting Architecture

**Reuses Story 3.2 Infrastructure:**

The `marketplaceRateLimits` table created in Story 3.2 already supports multiple providers via the `provider` field. BrickOwl simply uses `provider: "brickowl"` instead of `provider: "bricklink"`.

**Rate Limit Capacity for BrickOwl:**

Research BrickOwl's published rate limits. Common API rate limits are:

- 1,000 requests/day (conservative services)
- 5,000 requests/day (standard services, same as BrickLink)
- 10,000 requests/day (premium services)

**Default Recommendation**: Start with 5,000 requests/day (same as BrickLink) and adjust based on:

1. BrickOwl's actual published limits (check their API documentation)
2. User feedback about rate limit errors
3. Circuit breaker activation patterns

**Implementation Pattern (Identical to Story 3.2):**

```typescript
// Client pre-flight check
class BrickOwlStoreClient {
  async request(options) {
    // 1. Check quota BEFORE making request
    const quota = await ctx.runQuery(internal.marketplace.getQuotaState, {
      businessAccountId: this.businessAccountId,
      provider: "brickowl", // Only difference from BrickLink
    });

    // Same quota checking logic as BrickLink...
    // Same circuit breaker logic as BrickLink...

    // 2. Make API request
    const response = await fetch(url, {
      headers: {
        Authorization: this.apiKey, // Simpler than BrickLink OAuth
        ...
      }
    });

    // 3. Record quota usage AFTER successful request
    await ctx.runMutation(internal.marketplace.incrementQuota, {
      businessAccountId: this.businessAccountId,
      provider: "brickowl",
    });

    return response;
  }
}
```

**Per-Provider Quota Isolation:**

Each provider has completely independent quota tracking:

- BrickLink: 5,000 requests/day per business account
- BrickOwl: X requests/day per business account (to be determined)
- Future providers: Independent quotas

User can hit both providers' rate limits independently without affecting each other.

[Source: docs/stories/3.2.bricklink-client-inventory.story.md#database-backed-rate-limiting-architecture]

### Bulk Operations Strategy: BrickOwl's Batch API Advantage

**BrickOwl Batch Endpoint Specification:**

```typescript
// POST /v1/bulk/batch
{
  "requests": [
    {
      "endpoint": "inventory/create",
      "request_method": "POST",
      "params": [{ "boid": "12345", "quantity": 10, "price": 1.50, ... }]
    },
    {
      "endpoint": "inventory/update",
      "request_method": "POST",
      "params": [{ "lot_id": "ABC123", "relative_quantity": 5 }]
    },
    {
      "endpoint": "inventory/delete",
      "request_method": "POST",
      "params": [{ "lot_id": "XYZ789" }]
    }
  ]
}

// Response: Array of responses in same order as requests
[
  { /* result for create */ },
  { /* result for update */ },
  { /* result for delete */ }
]
```

**Batch API Key Features:**

1. **Mixed Operations**: Can batch different operation types (create, update, delete) in single call
2. **Maximum 50 Requests**: Per batch (BrickOwl limit)
3. **Ordered Responses**: Response array matches request order
4. **Individual Results**: Each operation has success/failure independently
5. **Significant Efficiency**: 50 operations = 1 API call (any operation type)

**Implementation Strategy:**

```typescript
// Efficient bulk update implementation
async bulkUpdateInventories(updates: Array<UpdatePayload>, options?: BulkOptions) {
  const chunks = chunkArray(updates, 50); // BrickOwl max
  const results: BulkOperationResult[] = [];

  for (const [batchIndex, chunk] of chunks.entries()) {
    // Build batch request
    const batchRequest = {
      requests: chunk.map(update => ({
        endpoint: "inventory/update",
        request_method: "POST",
        params: [{
          lot_id: update.lotId,
          ...mapConvexToBrickOwlUpdate(update)
        }]
      }))
    };

    // Single API call for 50 updates!
    const response = await this.request({
      method: "POST",
      path: "/v1/bulk/batch",
      body: batchRequest
    });

    // Process batch results
    for (const [index, result] of response.entries()) {
      results.push({
        success: !result.error,
        brickowlLotId: result.lot_id,
        error: result.error ? normalizeApiError(result.error) : undefined
      });
    }

    // Progress callback
    options?.onProgress?.({
      completed: (batchIndex + 1) * chunk.length,
      total: updates.length,
      currentBatch: batchIndex + 1,
      totalBatches: chunks.length
    });
  }

  return aggregateResults(results);
}
```

**Efficiency Comparison with BrickLink:**

| Scenario             | BrickLink (Story 3.2)      | BrickOwl (Story 3.3) | Efficiency Gain              |
| -------------------- | -------------------------- | -------------------- | ---------------------------- |
| **Create 500 items** | 5 API calls (bulk)         | 10 API calls (batch) | BrickLink better (2x)        |
| **Update 500 items** | 500 API calls (sequential) | 10 API calls (batch) | **BrickOwl better (50x)** ⭐ |
| **Delete 500 items** | 500 API calls (sequential) | 10 API calls (batch) | **BrickOwl better (50x)** ⭐ |
| **Mixed ops (500)**  | >500 API calls             | 10 API calls (batch) | **BrickOwl better (50x)** ⭐ |

**Story 3.4 Integration - Sync Efficiency:**

When Story 3.4 implements the orchestration layer:

- **Initial bulk sync** (all creates): BrickLink slightly more efficient (100 items/call vs 50)
- **Ongoing sync** (mixed operations): **BrickOwl dramatically more efficient** due to batch API
- **Update-heavy workloads**: BrickOwl will sync 50x faster and consume 50x less quota
- **Real-world scenario**: User adjusts 100 prices → BrickLink: 100 API calls, BrickOwl: 2 API calls

[Source: docs/external-documentation/api-brickowl/bulk-requests.md; docs/stories/3.2.bricklink-client-inventory.story.md#bulk-operations-strategy-for-api-efficiency]

### Data Models

**BrickOwl Inventory API Response Shape:**

```typescript
interface BrickOwlInventoryResponse {
  lot_id: string; // BrickOwl's internal lot identifier
  boid: string; // BrickOwl item identifier (part number)
  type:
    | "Part"
    | "Set"
    | "Minifigure"
    | "Gear"
    | "Sticker"
    | "Minibuild"
    | "Instructions"
    | "Packaging";
  color_id?: number; // Required for Parts, optional for Gear/Minibuild
  quantity: number;
  price: number; // Number (not string like BrickLink)
  condition:
    | "new"
    | "news"
    | "newc"
    | "newi"
    | "usedc"
    | "usedi"
    | "usedn"
    | "usedg"
    | "useda"
    | "other";
  for_sale: 0 | 1; // Available for sale flag
  absolute_quantity?: number; // For updates: set exact quantity
  relative_quantity?: number; // For updates: adjust by delta (+/-)
  sale_percent?: number; // Sale percentage (-95 to 95)
  my_cost?: number; // Personal cost tracking
  lot_weight?: number; // Custom weight in grams
  personal_note?: string;
  public_note?: string;
  bulk_qty?: number; // Bulk quantity (must buy in multiples)
  tier_price?: string; // Format: "qty:price,qty:price" (e.g., "100:0.05,200:0.04")
  external_id_1?: string; // Optional external reference (our SKU)
}
```

**Key Differences from BrickLink:**

| Field              | BrickLink                | BrickOwl                  | Notes                    |
| ------------------ | ------------------------ | ------------------------- | ------------------------ |
| **ID Field**       | `inventory_id` (number)  | `lot_id` (string)         | Different type!          |
| **Part Number**    | `item.no` (nested)       | `boid` (top-level)        | Simpler structure        |
| **Price**          | String with decimals     | Number                    | Easier to work with      |
| **Condition**      | `N`/`U`                  | Full enum codes           | More detailed            |
| **Quantity Delta** | `"+5"` string prefix     | `relative_quantity` field | Separate field vs prefix |
| **External Ref**   | None (inventory_id only) | `external_id_1`           | Can store our SKU!       |

[Source: docs/external-documentation/api-brickowl/store-inventory.md]

**Convex inventoryItems Schema (Target Mapping):**

```typescript
{
  businessAccountId: Id<"businessAccounts">;
  sku: string; // Maps to external_id_1 in BrickOwl
  name: string;
  partNumber: string; // Maps from boid
  colorId: string; // Maps from color_id (converted to string)
  location: string; // Not directly supported in BrickOwl, tracked locally
  quantityAvailable: number; // Maps from quantity
  quantityReserved: number;
  quantitySold: number;
  status: "available" | "reserved" | "sold";
  condition: "new" | "used"; // Maps from condition (simplified)
  price?: number; // Maps from price (number)
  notes?: string; // Maps from personal_note or public_note
  brickowlLotId?: string; // Maps from lot_id (track BrickOwl sync)
  bricklinkInventoryId?: number; // From Story 3.2 (track BrickLink sync)
  createdBy: Id<"users">;
  createdAt: number;
  updatedAt?: number;
  isArchived?: boolean;
  deletedAt?: number;
}
```

**Dual Marketplace Tracking:**

Note that `inventoryItems` will have **both** `brickOwlLotId` and `bricklinkInventoryId` fields. This enables:

- Single inventory item synced to both marketplaces
- Independent sync status per marketplace
- Marketplace-specific IDs for update/delete operations
- Story 3.4 orchestration can manage multi-marketplace sync

**Mapping Strategy:**

- **External ID Advantage**: Use `external_id_1` to store our `sku` - enables efficient lookups when pulling from BrickOwl
- **Condition Simplification**: Map BrickOwl's detailed condition codes to our simplified `new`/`used` enum (store full condition in notes if needed)
- **Quantity Updates**: Support both absolute (`absolute_quantity`) and relative (`relative_quantity`) - choose based on Story 3.4's sync strategy
- **Location Handling**: BrickOwl doesn't support location field - track separately in Convex, don't sync to BrickOwl
- **Dual Sync Tracking**: Store both marketplace IDs to enable multi-marketplace sync

[Source: docs/external-documentation/api-brickowl/store-inventory.md; docs/architecture/database-schema.md#inventoryitems; docs/architecture/data-models.md#inventoryitem]

### API Specifications

**BrickOwl Inventory Endpoints:**

```typescript
// List inventories (bulk read)
GET /v1/inventory/list?type={type}&active_only={0|1}&external_id_1={id}&lot_id={id}
Response: Array of BrickOwlInventoryResponse
Note: Returns array directly (no pagination wrapper like BrickLink)

// Create single inventory
POST /v1/inventory/create
Body: { boid, color_id?, quantity, price, condition, external_id?, ... }
Response: { lot_id, boid, quantity, price, ... }

// Update single inventory (can use lot_id OR external_id)
POST /v1/inventory/update
Body: {
  lot_id: "...", // OR external_id: "..."
  absolute_quantity?: 10, // Set exact quantity
  relative_quantity?: 5,  // OR adjust by delta
  price?: 1.50,
  ...
}
Response: Updated inventory object

// Delete single inventory (can use lot_id OR external_id)
POST /v1/inventory/delete
Body: { lot_id: "..." } // OR { external_id: "..." }
Response: Success confirmation

// ⭐ Bulk batch endpoint (up to 50 requests)
POST /v1/bulk/batch
Body: {
  requests: [
    { endpoint: "inventory/create", request_method: "POST", params: [{...}] },
    { endpoint: "inventory/update", request_method: "POST", params: [{...}] },
    { endpoint: "inventory/delete", request_method: "POST", params: [{...}] },
  ]
}
Response: Array of responses matching request order
Note: Mixed operation types in single batch! Up to 50 requests per call.
```

**Critical API Differences from BrickLink:**

1. **Identifier Flexibility**: Can identify inventory by `lot_id` (BrickOwl's ID) OR `external_id` (our SKU)
   - BrickLink only supports inventory_id
   - Makes sync more resilient - can recover if we lose lot_id tracking
2. **Quantity Update Modes**: Explicit fields for absolute vs relative

   - `absolute_quantity`: Set exact quantity (e.g., 10)
   - `relative_quantity`: Adjust by delta (e.g., +5 or -5)
   - BrickLink requires "+5" string prefix format

3. **Response Format**: Direct arrays vs wrapped responses

   - BrickLink: `{ meta, data: [...] }`
   - BrickOwl: `[...]` directly

4. **Batch Endpoint**: Universal batch support

   - BrickLink: Only CREATE supports bulk
   - BrickOwl: ALL operations via batch endpoint

5. **Price Type**: Number vs string
   - BrickLink: `"1.2000"` (fixed-point string)
   - BrickOwl: `1.20` (number)

[Source: docs/external-documentation/api-brickowl/store-inventory.md; docs/external-documentation/api-brickowl/bulk-requests.md]

### Component Specifications

N/A - This story is backend-only (no frontend components).

### File Locations

**Backend:**

- **Auth Module**: `convex/brickowl/auth.ts` (new file - API key authentication helpers)
- **Store Client** (This Story): `convex/brickowl/storeClient.ts` (new file - uses auth helpers + DB rate limiting for store operations)
- **Store Mappers**: `convex/brickowl/storeMappers.ts` (new file - bidirectional BrickOwl store ↔ Convex mapping, handles inventory now + orders in Epic 4)
- **Marketplace Functions**: `convex/functions/marketplace.ts` (extend with `createBrickOwlStoreClient()` factory)
- **Marketplace Types**: `convex/marketplaces/types.ts` (extend if needed - reuse existing `StoreOperationResult` interface)
- **Schema**: `convex/schema.ts` (extend `inventoryItems` with `brickowlLotId` field)

**Tests:**

- Auth Functions: `__tests__/backend/brickowl-auth.test.ts` (test API key helpers)
- Store Client: `__tests__/backend/brickowl-store-client.test.ts` (test store CRUD + batch operations + rate limiting)
- Store Mappers: `__tests__/backend/brickowl-store-mappers.test.ts` (test bidirectional mapping)

[Source: docs/architecture/unified-project-structure.md; docs/architecture/testing-strategy.md#test-organization]

### Technical Constraints

**API Key Authentication (User Credentials):**

- BrickOwl uses simple API key authentication (single key string)
- User API key stored encrypted; must decrypt at runtime using `decryptCredential()` from Story 3.1
- Pass API key in request headers: `Authorization: <api_key>`
- NEVER log API key values or Authorization headers in any logs/metrics
- Much simpler than BrickLink's OAuth 1.0a - no signature generation required

**Quantity Update Modes:**

- BrickOwl supports two update modes:
  - `absolute_quantity`: Set exact quantity (replaces current value)
  - `relative_quantity`: Add/subtract from current quantity (delta)
- Choose mode based on Story 3.4's sync strategy:
  - Use `absolute_quantity` when we know exact final quantity
  - Use `relative_quantity` for incremental adjustments
- Never send both fields in same request

**Dual Identifier System:**

- BrickOwl supports two ways to identify inventory:
  - `lot_id`: BrickOwl's internal identifier (returned on create)
  - `external_id`: Our SKU/reference (optional, we set this)
- **Recommended Strategy**: Always set `external_id_1 = sku` on create
  - Enables recovery if we lose lot_id tracking
  - Makes bulk operations more resilient
  - Simplifies debugging (can match by our SKU)

**Rate Limiting and Quota (Database-Backed):**

- **Architecture**: Database-backed quota tracking using `marketplaceRateLimits` Convex table (reuses Story 3.2 infrastructure)
- **Isolation**: BrickOwl quota completely separate from BrickLink quota; each business account has independent rate limit per provider
- **Enforcement**: Client layer performs pre-flight quota check and post-request recording via internal mutations/queries
- **Persistence**: Quota state persists across restarts and is shared across all Convex backend instances
- **Circuit Breaker**: Track consecutive failures; temporarily disable sync after 5 failures to prevent account suspension
- **Alerting**: Emit metric at 80% threshold; reset alert flag when window resets
- **HTTP 429 Handling**: Respect BrickOwl's `Retry-After` header if provided
- **Window Reset**: 24-hour rolling window with automatic reset logic in `incrementQuota` mutation
- **Capacity**: Research BrickOwl's published rate limits; default to conservative estimate (5,000/day like BrickLink) until confirmed

**Batch API Constraints:**

- Maximum 50 requests per batch call
- Can mix operation types (create, update, delete) in single batch
- Responses returned in same order as requests
- Each request can succeed or fail independently
- Batch itself can fail (network error, auth failure) - must retry entire batch

**Idempotency:**

- Generate request key (hash of payload) to dedupe bulk operations within same batch
- Support external idempotency keys via `options.idempotencyKey` - Story 3.4 will pass change log IDs
- NEVER auto-retry non-idempotent operations without idempotency key
- For batch operations, track which requests completed successfully to avoid re-executing on retry

**Structured Result Format (for Story 3.4 Integration):**

All CRUD operations return standardized result format for sync status tracking (reuses `StoreOperationResult` from Story 3.2):

```typescript
// Defined in convex/marketplaces/types.ts (from Story 3.2)
interface StoreOperationResult {
  success: boolean;
  brickowlLotId?: string; // BrickOwl uses string lot_id
  bricklinkInventoryId?: number; // BrickLink uses number inventory_id
  error?: {
    code: string; // e.g., "CONFLICT", "VALIDATION_ERROR", "RATE_LIMIT", "NOT_FOUND"
    message: string; // User-friendly error message
    details?: any; // Additional error context
  };
  marketplaceStatus?: string; // Provider's status field if available
  correlationId: string; // For tracing
}
```

[Source: docs/external-documentation/api-brickowl/store-inventory.md; docs/architecture/backend-architecture.md#actions-external-api-orchestration; docs/prd/epic-3-inventory-management.md#story-34; docs/stories/3.2.bricklink-client-inventory.story.md#technical-constraints]

### Error Handling

**Backend:**

- Use `ConvexError` for user-facing errors with helpful messages:
  - "BrickOwl credentials not configured" → guide to settings page
  - "BrickOwl API rate limit exceeded" → show retry-after time
  - "Invalid inventory data" → show which fields failed validation
- Use `normalizeApiError()` helper from `convex/lib/external/types.ts` for consistent error formatting
- Log all errors server-side with correlation ID but return safe messages to client
- Handle BrickOwl API errors gracefully:
  - HTTP 400 (Bad Request) → validation error, surface field-level details
  - HTTP 401 (Unauthorized) → API key invalid/expired, prompt user to update credentials
  - HTTP 404 (Not Found) → inventory lot doesn't exist on BrickOwl
  - HTTP 429 (Too Many Requests) → rate limit, show wait time
  - HTTP 500 (Server Error) → transient failure, retry with backoff

**Batch Operation Error Handling:**

- Track partial failures with detailed context: `{ batchIndex, requestIndex, request, error }`
- Return comprehensive result: `{ succeeded: number, failed: number, errors: Array<...> }`
- Allow caller to decide whether to retry failed requests or surface errors to user
- Log batch operation summary: `{ correlationId, totalRequests, succeeded, failed, durationMs }`
- For batch API failures (entire batch fails), retry entire batch with exponential backoff

[Source: docs/architecture/error-handling-strategy.md; docs/architecture/backend-architecture.md#function-template; docs/prd/epic-3-inventory-management.md#story-33]

### Security Considerations

**Credential Protection:**

- User marketplace credentials decrypted only server-side in actions (never exposed to client)
- Use `internal` actions for client creation - NEVER expose credential retrieval as public API
- RBAC enforcement: only owner role can trigger inventory sync operations
- All API requests log correlation ID but NEVER log API key values, auth headers, or sensitive data

**Tenant Isolation:**

- All operations require `businessAccountId` parameter
- Verify user belongs to business account before creating inventory client
- Rate limiting tracked per business account (separate quota per tenant)
- Never expose one tenant's BrickOwl data to another tenant

**Rate Limiting:**

- Respect BrickOwl's rate limits to avoid account suspension
- Implement circuit breaker: disable sync for account after repeated failures
- Surface clear error messages to users when rate limited (don't expose technical details)

**External ID Security:**

- When using `external_id_1`, ensure we don't leak sensitive information
- Use our internal SKU (safe to expose) not internal database IDs
- BrickOwl may expose `external_id` in public marketplace listings if `public_note` references it

[Source: docs/architecture/security-and-performance.md#security-requirements; docs/architecture/backend-architecture.md#authentication-and-authorization]

### Integration with Story 3.1 (Marketplace Credentials)

**Credential Retrieval and Client Factory Pattern:**

```typescript
// convex/functions/marketplace.ts
export const createBrickOwlStoreClient = async (
  ctx: ActionCtx,
  businessAccountId: Id<"businessAccounts">,
): Promise<BrickOwlStoreClient> => {
  // 1. Query marketplace credentials
  const credentials = await ctx.runQuery(internal.marketplace.getEncryptedCredentials, {
    businessAccountId,
    provider: "brickowl",
  });

  if (!credentials || !credentials.isActive) {
    throw new ConvexError(
      "BrickOwl credentials not configured. Please add your credentials in Settings.",
    );
  }

  // 2. Decrypt credentials (simpler than BrickLink - single API key)
  const apiKey = await decryptCredential(credentials.brickowlApiKey);

  // 3. Create and return client with ActionCtx for DB rate limiting
  return new BrickOwlStoreClient(
    { apiKey },
    businessAccountId,
    ctx, // ActionCtx enables DB-backed rate limiting
  );
};
```

**Why ActionCtx is Required:**

The store client needs `ActionCtx` to:

- Call `ctx.runQuery(internal.marketplace.getQuotaState, ...)` for pre-flight quota checks
- Call `ctx.runMutation(internal.marketplace.incrementQuota, ...)` for post-request recording
- Call `ctx.runMutation(internal.marketplace.recordFailure, ...)` for circuit breaker tracking

This is why the client is instantiated **inside an action**, not as a singleton.

[Source: docs/stories/3.1.user-marketplace-credentials-byok-on-settings.story.md#dev-notes; docs/architecture/backend-architecture.md#internal-functions-server-only-building-blocks]

### Integration with Story 3.4 (Orchestration Layer)

Story 3.4 will consume both BrickLink and BrickOwl clients using the **same interface** to sync inventory changes. The orchestration layer will determine which providers to sync based on user's configured credentials.

**Pattern 1: Multi-Provider Sync (Story 3.4 Core Capability)**

```typescript
// Story 3.4 sync action will sync to ALL configured providers
export const syncInventoryChange = internalAction({
  args: { changeId: v.id("inventoryChangeLog") },
  handler: async (ctx, { changeId }) => {
    // Get change details
    const change = await ctx.runQuery(internal.inventory.getChange, { changeId });

    // Determine which providers user has configured
    const providers = await getConfiguredProviders(change.businessAccountId);

    // Sync to each provider (parallel for efficiency)
    const syncResults = await Promise.all([
      providers.includes("bricklink") ? syncToBricklink(ctx, change) : null,
      providers.includes("brickowl") ? syncToBrickOwl(ctx, change) : null,
    ]);

    // Update sync status for each provider
    await ctx.runMutation(internal.inventory.updateMultiProviderSyncStatus, {
      changeId,
      bricklinkResult: syncResults[0],
      brickowlResult: syncResults[1],
      syncedAt: Date.now(),
    });
  },
});

async function syncToBrickOwl(ctx: ActionCtx, change: InventoryChange) {
  const client = await createBrickOwlStoreClient(ctx, change.businessAccountId);

  switch (change.changeType) {
    case "create":
      return await client.createInventory(change.newData, {
        idempotencyKey: `${change._id}-brickowl`,
      });
    case "update":
      return await client.updateInventory(change.brickowlLotId, change.delta, {
        idempotencyKey: `${change._id}-brickowl`,
      });
    case "delete":
      return await client.deleteInventory(change.brickowlLotId, {
        idempotencyKey: `${change._id}-brickowl`,
      });
  }
}
```

**Pattern 2: Efficient Bulk Initial Sync (Multi-Provider)**

```typescript
// Story 3.4 will support bulk initial sync to both providers
export const initialBulkSync = internalAction({
  args: { businessAccountId: v.id("businessAccounts") },
  handler: async (ctx, { businessAccountId }) => {
    const providers = await getConfiguredProviders(businessAccountId);
    const localInventory = await ctx.runQuery(internal.inventory.getAllInventory, {
      businessAccountId,
    });

    // Sync to each provider in parallel
    const results = await Promise.all([
      providers.includes("bricklink")
        ? syncBulkToBricklink(ctx, businessAccountId, localInventory)
        : null,
      providers.includes("brickowl")
        ? syncBulkToBrickOwl(ctx, businessAccountId, localInventory)
        : null,
    ]);

    return {
      bricklink: results[0],
      brickowl: results[1],
    };
  },
});

async function syncBulkToBrickOwl(
  ctx: ActionCtx,
  businessAccountId: Id<"businessAccounts">,
  inventory: InventoryItem[],
) {
  const client = await createBrickOwlStoreClient(ctx, businessAccountId);

  // Use BrickOwl's efficient batch API
  const payloads = inventory.map((item) => ({
    ...mapConvexToBrickOwlCreate(item),
    external_id: item.sku, // Set our SKU as external reference
  }));

  // BrickOwl: 1,000 items = 20 API calls (50 per batch)
  // vs BrickLink: 1,000 items = 10 API calls (100 per bulk create)
  const result = await client.bulkCreateInventories(payloads, {
    chunkSize: 50,
    onProgress: (p) => updateUI(p),
  });

  // Query back to get lot_ids (or use external_id for future lookups)
  const createdInventories = await client.getInventories();

  // Match and update Convex records with BrickOwl lot_ids
  await matchAndUpdateLotIds(ctx, businessAccountId, createdInventories);

  return result;
}
```

**Pattern 3: Provider-Specific Optimization (Story 3.4 Efficiency)**

```typescript
// Story 3.4 can optimize based on provider capabilities
export const syncPendingChanges = internalAction({
  args: { businessAccountId: v.id("businessAccounts") },
  handler: async (ctx, { businessAccountId }) => {
    const pendingChanges = await getPendingChanges(businessAccountId);
    const providers = await getConfiguredProviders(businessAccountId);

    // Optimize for each provider's strengths
    if (providers.includes("brickowl")) {
      // BrickOwl: Batch ALL operation types efficiently
      const brickowlClient = await createBrickOwlStoreClient(ctx, businessAccountId);
      await syncChangesBatched(brickowlClient, pendingChanges); // Mixed batch API
    }

    if (providers.includes("bricklink")) {
      // BrickLink: Separate handling for creates vs updates
      const bricklinkClient = await createBricklinkStoreClient(ctx, businessAccountId);
      const creates = pendingChanges.filter((c) => c.type === "create");
      const updates = pendingChanges.filter((c) => c.type === "update");

      await bricklinkClient.bulkCreateInventories(creates); // Efficient bulk
      await bricklinkClient.bulkUpdateInventories(updates); // Sequential
    }
  },
});
```

**Key Requirements for Story 3.4 Integration:**

1. ✅ Both clients use same `StoreOperationResult` interface
2. ✅ Both clients support external idempotency keys (change IDs)
3. ✅ Both clients return structured results for sync status tracking
4. ✅ Both clients support rollback via inverse operations
5. ✅ Both clients provide detailed error responses for conflict handling
6. ✅ Both clients include correlation IDs for tracing through sync pipeline
7. ✅ Convex schema tracks both `bricklinkInventoryId` and `brickowlLotId` for multi-provider sync

**Performance Characteristics for Story 3.4:**

- **Initial Sync (all creates)**: BrickLink slightly faster (100/call vs 50/call)
- **Ongoing Sync (mixed ops)**: **BrickOwl dramatically faster** (50x for updates/deletes)
- **Rate Limit Conservation**: BrickOwl more efficient for update-heavy workloads
- **User Experience**: Both sync in background, multi-provider sync status visible in UI

[Source: docs/prd/epic-3-inventory-management.md#story-34; docs/architecture/backend-architecture.md#internal-functions-server-only-building-blocks; docs/stories/3.2.bricklink-client-inventory.story.md#integration-with-story-34-orchestration-layer]

### Testing Approach

**Unit Tests (Vitest):**

- Mock HTTP requests using test factories
- Mock crypto functions for deterministic tests
- Verify mapper functions with comprehensive fixtures covering all BrickOwl field variations
- Test quota tracking, backoff logic, error normalization in isolation
- Test batch request formatting and response parsing

**Integration Tests (Future - Story 3.4):**

- Story 3.4 (Convex Orchestration Layer) will add integration tests for end-to-end sync flows
- Will test: Convex → BrickOwl sync, BrickOwl → Convex sync, conflict resolution, rollback scenarios
- Will test multi-provider sync (BrickLink + BrickOwl simultaneously)

**HTTP Mocking Pattern:**

```typescript
// Mock fetch for deterministic tests
global.fetch = jest.fn((url, options) => {
  if (url.includes("/v1/inventory/list")) {
    return Promise.resolve({
      ok: true,
      status: 200,
      headers: new Headers(),
      json: async () => [mockBrickOwlInventoryResponse], // Direct array
    });
  }
  if (url.includes("/v1/bulk/batch")) {
    return Promise.resolve({
      ok: true,
      status: 200,
      headers: new Headers(),
      json: async () => mockBatchResponses, // Array matching requests
    });
  }
  throw new Error(`Unmocked endpoint: ${url}`);
});
```

[Source: docs/architecture/testing-strategy.md#backend-tests; docs/architecture/coding-standards.md#testing-standards]

## Change Log

| Date       | Version | Description                                                                                                                                                        | Author |
| ---------- | ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------ |
| 2025-10-09 | v1.0    | Initial draft of Story 3.3 following Story 3.2 pattern with BrickOwl-specific adaptations (API key auth, batch API, dual identifier system, parallel architecture) | Bob    |

## Dev Agent Record

### Agent Model Used

_(Populated by Dev Agent during implementation)_

### Debug Log References

_(Populated by Dev Agent during implementation)_

### Completion Notes List

_(Populated by Dev Agent during implementation)_

### File List

_(Populated by Dev Agent during implementation)_

## QA Results

_(Populated by QA Agent after implementation)_
