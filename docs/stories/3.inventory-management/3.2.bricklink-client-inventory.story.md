# Story 3.2: BrickLink Store Client (Inventory Lots + Mappers)

## Status

Done

## Story

**As a** system,
**I want** a robust BrickLink client with inventory lot CRUD and data mappers,
**so that** we can synchronize our users' store inventory to/from BrickLink in a reliable and maintainable way.

## Acceptance Criteria

1. **3.2.1:** Implement a typed BrickLink client that authenticates with user-provided credentials and supports required OAuth 1.0a signing.
2. **3.2.2:** Provide CRUD operations for store inventory lots: create lot, read/get lot(s), update lot, delete lot; include list/pagination support where the API allows.
3. **3.2.3:** Implement data mappers to transform BrickLink request/response payloads into our Convex `inventories` schema shapes and back (including fields like part identifier, condition, quantity, price, location, remarks/notes, status).
4. **3.2.4:** Support bulk operations where BrickLink API enables them; if not supported natively, provide chunked/sequenced operations with progress and partial-failure reporting.
5. **3.2.5:** Add resiliency: handle rate limits and transient failures via exponential backoff, retry policies, and idempotency (dedupe by request keys).
6. **3.2.6:** Provide structured logging (with correlation IDs) and metrics around request counts, latency, errors, and throttle events; no secrets in logs.
7. **3.2.7:** Include unit tests using HTTP mocking to validate signing, mapping correctness, error handling, and rate-limit behavior.

## Tasks / Subtasks

- [x] Task 1: Refactor OAuth signing and create specialized inventory client (AC: 3.2.1)

  - [x] **Extract Shared OAuth Logic**: Create `convex/bricklink/oauth.ts` module with reusable OAuth 1.0a signing functions:
    - Extract `percentEncode()` helper from existing `BricklinkClient`
    - Extract OAuth signature generation logic into `generateOAuthSignature(credentials, method, url, params)` function
    - Extract Authorization header building into `buildAuthorizationHeader(credentials, signature, oauthParams)` function
    - Add `generateOAuthParams(timestamp, nonce)` helper for OAuth parameter construction
    - CRITICAL: Make functions pure and testable (accept credentials as parameter, not from env)
  - [x] **Refactor Existing Catalog Client** (`convex/bricklink/catalogClient.ts`, renamed from `bricklinkClient.ts`):
    - Replace inline OAuth logic with calls to shared `oauth.ts` functions
    - Keep existing credential source (environment variables via `getBricklinkCredentials()`)
    - Keep existing static in-memory quota tracking (works for single credential set)
    - Keep existing catalog methods (colors, categories, parts, price guides)
    - No breaking changes - this is internal refactor for code reuse
    - Export renamed to `catalogClient` to clarify this is for BrickOps internal catalog queries, not user store operations
  - [x] **Create New Store Client** (`convex/bricklink/storeClient.ts`):
    - New class that accepts user credentials and `businessAccountId` as constructor arguments
    - Use shared OAuth functions from `oauth.ts` for signing
    - Implement database-backed rate limiting (pre-flight check + post-request recording)
    - Implement store inventory CRUD methods (separate from catalog methods)
    - CRITICAL: Use user credentials passed to constructor (NOT env variables)
    - NOTE: Named "Store" not "Inventory" - will also handle orders in Epic 4
  - [x] Add validation to ensure credentials are properly formatted before making requests in both clients
  - [x] [Source: docs/architecture/backend-architecture.md#actions-external-api-orchestration; docs/external-documentation/api-bricklink/authentication.md; docs/stories/3.1.user-marketplace-credentials-byok-on-settings.story.md#dev-notes]

- [x] Task 2: Implement inventory lot CRUD operations (AC: 3.2.2)

  - [x] Implement `getInventories(options?: { itemType?, status?, categoryId?, colorId? })` method for listing inventory lots with filtering support (maps to `GET /inventories`)
  - [x] Implement `getInventory(inventoryId: number)` method for fetching single inventory lot (maps to `GET /inventories/{inventory_id}`)
  - [x] Implement `createInventory(payload)` method for creating single inventory lot (maps to `POST /inventories`)
  - [x] Implement `createInventories(payloads[])` method for **NATIVE** bulk inventory creation - sends array in single API call (maps to `POST /inventories` with array body, returns `{ meta, data: null }`)
  - [x] Implement `updateInventory(inventoryId: number, payload)` method for updating single inventory lot (maps to `PUT /inventories/{inventory_id}`)
  - [x] Implement `deleteInventory(inventoryId: number)` method for deleting single inventory lot (maps to `DELETE /inventories/{inventory_id}`)
  - [x] CRITICAL: Quantity updates must use +/- delta syntax per BrickLink API requirements (e.g., `quantity: "+5"` or `quantity: "-3"`)
  - [x] CRITICAL: BrickLink supports native bulk CREATE only - UPDATE and DELETE are single-item operations requiring chunking (see Task 4)
  - [x] [Source: docs/external-documentation/api-bricklink/inventory.md; docs/prd/epic-3-inventory-management.md#story-32]

- [x] Task 3: Implement data mappers for BrickLink <-> Convex schema (AC: 3.2.3)

  - [x] Create `convex/bricklink/storeMappers.ts` with bidirectional mapper functions for store data (inventory now, orders in Epic 4)
  - [x] Implement `mapBricklinkToConvexInventory(bricklinkInventory)` to transform BrickLink inventory response to our `inventoryItems` schema (map: `inventory_id` → `bricklinkLotId`, `item.no` → `partNumber`, `color_id` → `colorId`, `quantity` → `quantityAvailable`, `new_or_used` → `condition`, `unit_price` → `price`, `description` → `notes`, `is_stock_room`/`stock_room_id` → `location`)
  - [x] Implement `mapConvexToBricklinkInventory(convexInventory)` to transform our inventory to BrickLink create/update payload (reverse mapping with proper field names and format)
  - [x] Handle optional fields gracefully (e.g., BrickLink's `completeness` only for SET type, tier pricing, bulk settings)
  - [x] Include TypeScript types for BrickLink inventory request/response shapes based on API documentation
  - [x] Add validation for required fields and proper enum values (condition: "N"/"U", item type, etc.)
  - [x] [Source: docs/external-documentation/api-bricklink/inventory.md; docs/architecture/data-models.md#inventoryitem; docs/architecture/backend-architecture.md#function-template]

- [x] Task 4: Implement bulk operations with chunking (AC: 3.2.4)

  - [x] **BULK CREATE (Native BrickLink Support - Most Efficient)**:
    - Implement `bulkCreateInventories(payloads[], options?: { chunkSize?, onProgress? })` that chunks into batches and calls native `createInventories()` (single API call per chunk)
    - Default chunk size: 100 items per batch (BrickLink recommended limit for reliable processing)
    - BrickLink API accepts array in single POST: `POST /inventories` with `[{...}, {...}]` body - returns `{ meta, data: null }` on success
    - This is HIGHLY EFFICIENT: 100 inventory creations = 1 API call (vs 100 calls for individual creates)
    - Critical for Story 3.4 initial bulk sync when user first connects BrickLink
    - **GOTCHA**: Bulk create returns `null` data (no inventory IDs) - if IDs needed, must query after: `GET /inventories` and match by part/color/condition, OR use individual creates (trades efficiency for immediate ID tracking)
  - [x] **BULK UPDATE (No Native Support - Sequential Required)**:
    - Implement `bulkUpdateInventories(updates[], options?)` that sequences individual `updateInventory()` calls (no native bulk API)
    - Each update requires separate `PUT /inventories/{id}` call - BrickLink does not support batch updates
    - Chunk into batches of 50 to manage rate limiting and provide progress feedback
    - Add delay between chunks (e.g., 100ms) to avoid rate limit spikes
  - [x] **BULK DELETE (No Native Support - Sequential Required)**:
    - Implement `bulkDeleteInventories(ids[], options?)` that sequences individual `deleteInventory()` calls (no native bulk API)
    - Each delete requires separate `DELETE /inventories/{id}` call
    - Chunk into batches of 50 with progress tracking
  - [x] **Common Bulk Features**:
    - Add progress callback: `onProgress({ completed: number, total: number, currentBatch: number, totalBatches: number })`
    - Track partial failures: collect all errors with context (batch index, item index, error details) and return comprehensive result: `{ succeeded: number, failed: number, errors: Array<{ batchIndex, itemIndex, item, error }> }`
    - Add idempotency: dedupe requests by generating stable request key (hash of payload) and skip duplicate operations within same bulk batch
    - CRITICAL: Support external idempotency keys via `options.idempotencyKey?` parameter - Story 3.4 will pass change log IDs for deduplication across retry attempts
    - Return structured result for each operation: `{ success: boolean, bricklinkLotId?: number, error?: { code, message, details }, marketplaceStatus?: string }` to support Story 3.4 sync status tracking
  - [x] **Rate Limit Optimization**: Track API calls consumed: bulk create of 100 items = 1 call, bulk update of 100 items = 100 calls - balance batch size with quota conservation
  - [x] [Source: docs/external-documentation/api-bricklink/inventory.md#create-store-inventories; docs/prd/epic-3-inventory-management.md#story-32-notes; docs/prd/epic-3-inventory-management.md#story-34; docs/architecture/backend-architecture.md#actions-external-api-orchestration]

- [x] Task 5: Database-backed rate limiting (AC: 3.2.5 - per-user quota tracking)

  - [x] Create `marketplaceRateLimits` table in schema (if not exists) for persistent quota tracking per business account and provider
  - [x] Create internal queries in `convex/functions/marketplace.ts`: `getQuotaState(businessAccountId, provider)` returns current quota usage and capacity
  - [x] Create internal mutation in `convex/functions/marketplace.ts`: `incrementQuota(businessAccountId, provider)` atomically increments request count with window reset logic
  - [x] In `BricklinkStoreClient.request()`: implement pre-flight quota check by calling `getQuotaState()` before making API request
  - [x] If quota exceeded, throw `ConvexError` with code `RATE_LIMIT_EXCEEDED`, include `retryAfterMs` for Story 3.4 retry scheduling
  - [x] In `BricklinkStoreClient.request()`: implement post-request quota recording by calling `incrementQuota()` after successful API call
  - [x] Add quota alert at 80% threshold: emit metric `external.bricklink.store.quota.alert` when business account reaches warning level
  - [x] CRITICAL: Quota tracking is per business account (tenant-isolated) and separate from global BrickOps catalog quota
  - [x] [Source: docs/architecture/backend-architecture.md#actions-external-api-orchestration; docs/prd/epic-3-inventory-management.md#story-32]

- [x] Task 6: Resiliency patterns (AC: 3.2.5)

  - [x] Implement exponential backoff for transient failures (HTTP 5xx, network errors): start with 1s delay, double each retry up to max 32s, max 5 retries
  - [x] Handle BrickLink HTTP 429 responses: extract `Retry-After` header if available, implement respectful backoff
  - [x] Implement circuit breaker pattern: if 5 consecutive failures for a business account, temporarily disable that account's BrickLink sync for 5 minutes (track in `marketplaceRateLimits` table with `circuitBreakerOpenUntil` field)
  - [x] Add retry policy configuration: `{ maxRetries: 5, initialDelayMs: 1000, maxDelayMs: 32000, backoffMultiplier: 2 }`
  - [x] CRITICAL: Never retry non-idempotent operations (POST create) automatically; only retry safe operations (GET, PUT with same payload, DELETE)
  - [x] [Source: docs/architecture/backend-architecture.md#actions-external-api-orchestration; docs/architecture/coding-standards.md#critical-rules]

- [x] Task 7: Structured logging and metrics (AC: 3.2.6)

  - [x] Add correlation ID generation for all operations: `crypto.randomUUID()` passed through entire request chain
  - [x] Use existing `recordMetric()` helper from `convex/lib/external/metrics.ts` for tracking: `external.bricklink.store.request`, `external.bricklink.store.success`, `external.bricklink.store.error`, `external.bricklink.store.retry`, `external.bricklink.store.quota`
  - [x] Log request metadata: `{ correlationId, operation, businessAccountId, itemCount (for bulk), durationMs, retryCount }`
  - [x] Log error details: `{ correlationId, operation, errorCode, errorMessage, httpStatus, businessAccountId }` - NEVER log credential values or auth headers
  - [x] Add metric for bulk operation progress: `external.bricklink.store.bulk.progress { completed, total, batchIndex }`
  - [x] Reuse existing `normalizeApiError()` from `convex/lib/external/types.ts` for consistent error formatting
  - [x] [Source: docs/architecture/backend-architecture.md#convex-function-patterns-and-best-practices; docs/prd/epic-3-inventory-management.md#story-32]

- [ ] Task 8: Unit tests with HTTP mocking (AC: 3.2.7)

  - [ ] Create `__tests__/backend/bricklink-store-client.test.ts` using Vitest and HTTP mocking
  - [ ] Test OAuth 1.0a signing correctness: mock timestamp and nonce, verify generated Authorization header matches expected signature
  - [ ] Test CRUD operations: mock BrickLink API responses for each operation (get, list, create, update, delete), verify request payloads and response parsing
  - [ ] Test data mapper bidirectional conversion: verify BrickLink → Convex and Convex → BrickLink transformations preserve all fields correctly
  - [ ] Test bulk operations: verify chunking logic, progress callbacks, partial failure handling
  - [ ] Test database-backed rate limiting:
    - Mock quota queries/mutations
    - Verify pre-flight quota check prevents API call when quota exceeded
    - Verify post-request quota recording increments counter
    - Test window reset logic (24-hour rollover)
    - Test alert threshold triggers (80% capacity)
    - Test circuit breaker opens after 5 consecutive failures
    - Verify `RATE_LIMIT_EXCEEDED` error includes `retryAfterMs` for Story 3.4 scheduling
  - [ ] Test exponential backoff: simulate transient failures, verify retry delays follow expected backoff pattern
  - [ ] Test error handling: simulate various HTTP error codes (400, 401, 403, 404, 429, 500), verify proper error normalization and logging
  - [ ] Use `BricklinkStoreClient.createForTesting()` factory with mocked credentials, fixed timestamp/nonce for deterministic tests
  - [ ] [Source: docs/architecture/testing-strategy.md#backend-tests; docs/architecture/coding-standards.md#testing-standards]

- [x] Task 9: Client factory with credential decryption (Story 3.1 integration)

  - [x] Create internal action `marketplace.createBricklinkStoreClient(businessAccountId)` in `convex/functions/marketplace.ts`
  - [x] Action queries `marketplaceCredentials` table for the business account's BrickLink credentials (provider: "bricklink")
  - [x] If no credentials found or inactive, throw `ConvexError` with user-friendly message: "BrickLink credentials not configured. Please add your credentials in Settings."
  - [x] Decrypt credentials using `decryptCredential()` from `convex/lib/encryption.ts`
  - [x] Instantiate `BricklinkStoreClient` with: decrypted credentials, businessAccountId, AND ActionCtx (`ctx`) - client needs ctx for DB rate limiting
  - [x] Return client instance ready for store operations (inventory now, orders in Epic 4)
  - [x] Add RBAC check: only owner role can trigger store sync operations (check in Story 3.4 orchestration layer, not here)
  - [x] CRITICAL: Client constructor signature is `new BricklinkStoreClient(credentials, businessAccountId, ctx)` - ctx enables database queries/mutations for quota tracking
  - [x] [Source: docs/stories/3.1.user-marketplace-credentials-byok-on-settings.story.md#dev-notes; docs/architecture/backend-architecture.md#authentication-and-authorization; docs/architecture/backend-architecture.md#internal-functions-server-only-building-blocks]

- [x] Task 10: Rollback and compensating operations support (Story 3.4 rollback capability)

  - [x] All CRUD operations already support rollback pattern: `createInventory` → `deleteInventory`, `deleteInventory` → `createInventory` (with same payload), `updateInventory` → `updateInventory` (with previous values)
  - [x] Ensure all operation responses include enough information for Story 3.4 to construct compensating operations: `{ bricklinkLotId, previousQuantity?, previousPrice?, etc. }`
  - [x] Document rollback patterns in Dev Notes: for each operation type, specify the inverse operation and required data
  - [x] Add support for "dry-run" mode via `options.dryRun?: boolean` - validates operation without executing (for Story 3.4 rollback preview)
  - [x] [Source: docs/prd/epic-3-inventory-management.md#story-34-ac-347; docs/architecture/backend-architecture.md#actions-external-api-orchestration]

## Dev Notes

### Quick Reference: Which Client to Use?

**Use `catalogClient` (Catalog Client) for:**

- ✅ Global catalog data: colors, categories, parts, price guides
- ✅ BrickOps system operations (uses BrickOps credentials)
- ✅ Shared across all users
- ✅ Example: `await catalogClient.getRefreshedPart("3001")`

**Use `BricklinkStoreClient` (Store Client) for:**

- ✅ User's BrickLink store operations (inventory + orders)
- ✅ BYOK operations (uses user's marketplace credentials)
- ✅ Per-business-account operations
- ✅ Example: `const client = await createBricklinkStoreClient(businessAccountId); await client.getInventories()`

**Never:**

- ❌ Use catalog client for store endpoints (inventory, orders)
- ❌ Use store client for catalog endpoints (colors, parts)
- ❌ Mix BrickOps credentials with user store operations
- ❌ Mix user credentials with catalog operations

### Previous Story Insights

- Story 3.1 (User Marketplace Credentials) established secure credential storage with encryption at rest and test connection functionality. This story builds on that foundation by implementing the actual BrickLink inventory API client that consumes those user credentials.
- Story 2.3 (Advanced Catalog Management) implemented the BrickLink client for catalog data using BrickOps environment credentials. This story creates a parallel "Store" client for user's marketplace store management (inventory now, orders in Epic 4) using user marketplace credentials (BYOK model).
- [Source: docs/stories/3.1.user-marketplace-credentials-byok-on-settings.story.md; docs/stories/2.part-identification-catalog-integration/2.3.advanced-catalog-management.story.md]

### CRITICAL: Separate Specialized Clients Architecture

**Why Two Clients? (Pattern Justification)**

BrickOps uses **separate specialized clients** for catalog vs store, NOT a single unified client. This architectural decision is driven by fundamental differences:

| Aspect                 | Catalog Client                              | Store Client                                   |
| ---------------------- | ------------------------------------------- | ---------------------------------------------- |
| **Credentials Source** | Environment variables (BrickOps)            | User database (BYOK)                           |
| **Rate Limiting**      | Static in-memory (global quota)             | Database-backed (per-tenant)                   |
| **Quota Pool**         | Single shared pool (5K/day)                 | Independent per business account               |
| **Methods**            | Catalog queries (colors, parts, categories) | Store operations (inventory, orders, settings) |
| **Instantiation**      | Singleton (`catalogClient`)                 | Factory per request (user-specific)            |
| **Tenant Context**     | None (global catalog)                       | Requires `businessAccountId`                   |
| **Scope**              | Global reference data                       | User's marketplace store                       |

**Shared Code:** OAuth 1.0a signing logic extracted to `convex/bricklink/oauth.ts`

**1. Catalog Client (Existing - Story 2.3, Refactored in This Story):**

- **File**: `convex/bricklink/catalogClient.ts` (renamed from `bricklinkClient.ts`)
- **Credentials**: BrickOps environment variables via `getBricklinkCredentials()`
- **Purpose**: Query BrickLink catalog for part data, colors, categories (global reference data)
- **Quota Tracking**: Static in-memory class property (works for single credential set)
- **Rate Limiting**: Pre-request check increments static counter, throws on exceeded
- **Instantiation**: Singleton export `export const catalogClient = new BricklinkClient()`
- **Used By**: `catalog.searchParts`, `catalog.getPartDetails`, catalog refresh crons
- **Refactor**: Replace inline OAuth logic with shared `oauth.ts` functions (no breaking changes)
- **Export Renamed**: From `bricklinkClient` to `catalogClient` to clarify purpose

**2. Store Client (This Story - 3.2, Net New):**

- **File**: `convex/bricklink/storeClient.ts`
- **Credentials**: User marketplace credentials from `marketplaceCredentials` table (decrypted at runtime)
- **Purpose**: Manage user's BrickLink store (inventory in Story 3.2, orders in Epic 4, settings future)
- **Quota Tracking**: Database-backed via `marketplaceRateLimits` table (persistent, distributed-safe)
- **Rate Limiting**: Pre-flight queries DB, post-request mutates DB atomically per business account
- **Instantiation**: Factory pattern via internal action `createBricklinkStoreClient(businessAccountId)`
- **Used By**: Inventory sync actions (Story 3.4), order sync (Epic 4), user-initiated store operations
- **Constructor**: `new BricklinkStoreClient(userCredentials, businessAccountId, ctx)`

**CRITICAL: Never Mix Credentials**

```typescript
// ❌ WRONG - Using catalog client for user store operations
import { catalogClient } from "../bricklink/catalogClient";
await catalogClient.request({ path: "/inventories" }); // User store endpoint!
// This would query BrickOps store inventory, not the user's!

// ✅ CORRECT - Use specialized clients
// For catalog (system credentials)
import { catalogClient } from "../bricklink/catalogClient";
const catalogData = await catalogClient.getRefreshedPart("3001");

// For store (user credentials)
const storeClient = await ctx.runAction(internal.marketplace.createBricklinkStoreClient, {
  businessAccountId,
});
const userInventory = await storeClient.getInventories();
const userOrders = await storeClient.getOrders(); // Epic 4
```

**Refactoring Strategy:**

1. Extract shared OAuth logic to `oauth.ts` (pure functions)
2. Refactor `BricklinkClient` to use shared OAuth (internal cleanup)
3. Create `BricklinkStoreClient` using shared OAuth (net new)
4. Each client maintains its own rate limiting strategy (appropriate to use case)

**Directory Structure (Final State After Story 3.2):**

```text
convex/
├── bricklink/
│   ├── catalogClient.ts       # Catalog client (renamed from bricklinkClient.ts, refactored internally)
│   ├── bricklinkMappers.ts    # Catalog mappers (unchanged file name)
│   ├── dataRefresher.ts       # Catalog refresh jobs (unchanged)
│   ├── oauth.ts               # NEW - Shared OAuth 1.0a signing helpers
│   ├── storeClient.ts         # NEW - Store client (inventory + future orders)
│   └── storeMappers.ts        # NEW - Store data mappers
│
├── marketplaces/
│   └── types.ts               # NEW - Shared TypeScript interfaces across all marketplaces
│                              #   - StoreOperationResult
│                              #   - MarketplaceCredentials
│                              #   - RateLimitState
│
├── functions/
│   ├── marketplace.ts         # EXTEND - Add createBricklinkStoreClient() factory + rate limiting
│   └── inventory.ts           # Business logic (unchanged)
```

**Future: After Story 3.3 (BrickOwl):**

```text
convex/
├── bricklink/
│   └── ... (as above)
│
├── brickowl/
│   ├── storeClient.ts         # BrickOwl store client
│   ├── storeMappers.ts        # BrickOwl store mappers
│   └── auth.ts                # API key helpers
│
├── marketplaces/
│   └── types.ts               # Shared across BrickLink + BrickOwl
```

**Naming Rationale:**

- **"Store"** not "Inventory": BrickLink API calls it "store API" - encompasses inventory, orders, settings
- **Future-proof**: Store client will add order methods in Epic 4 without rename
- **Semantic accuracy**: User's marketplace store vs global part catalog
- **No breaking changes**: Keep existing catalog file names (only refactor internals)

**Class Structure for Store Client:**

```typescript
// convex/bricklink/storeClient.ts
import { ActionCtx } from "../_generated/server";
import { generateOAuthSignature, buildAuthorizationHeader } from "./oauth";

interface BricklinkUserCredentials {
  consumerKey: string;
  consumerSecret: string;
  tokenValue: string;
  tokenSecret: string;
}

export class BricklinkStoreClient {
  private readonly credentials: BricklinkUserCredentials;
  private readonly businessAccountId: Id<"businessAccounts">;
  private readonly ctx: ActionCtx; // Needed for DB rate limiting

  constructor(
    credentials: BricklinkUserCredentials,
    businessAccountId: Id<"businessAccounts">,
    ctx: ActionCtx,
  ) {
    this.credentials = credentials;
    this.businessAccountId = businessAccountId;
    this.ctx = ctx;
  }

  async request(options: RequestOptions) {
    // 1. Check quota (DB query)
    const quota = await this.ctx.runQuery(internal.marketplace.getQuotaState, {
      businessAccountId: this.businessAccountId,
      provider: "bricklink",
    });

    // Validate quota...

    // 2. Sign request using shared OAuth functions
    const signature = await generateOAuthSignature(this.credentials, method, url, params);

    const authorization = buildAuthorizationHeader(this.credentials, signature, oauthParams);

    // 3. Make API call
    const response = await fetch(url, { headers: { Authorization: authorization } });

    // 4. Record usage (DB mutation)
    await this.ctx.runMutation(internal.marketplace.incrementQuota, {
      businessAccountId: this.businessAccountId,
      provider: "bricklink",
    });

    return response;
  }

  // Story 3.2: Inventory CRUD methods
  async getInventories(...): Promise<BricklinkInventory[]>
  async createInventory(...): Promise<BricklinkInventory>
  async createInventories(...): Promise<void>
  async updateInventory(...): Promise<BricklinkInventory>
  async deleteInventory(...): Promise<void>

  // Epic 4: Order methods (placeholder for future)
  // async getOrders(...): Promise<BricklinkOrder[]>
  // async updateOrderStatus(...): Promise<BricklinkOrder>
}
```

**Catalog Client Refactor (No Breaking Changes):**

```typescript
// convex/bricklink/catalogClient.ts (renamed from bricklinkClient.ts, refactored)
import { generateOAuthSignature, buildAuthorizationHeader } from "./oauth";

export class BricklinkClient {
  // Keep existing: env credentials, static quota, singleton pattern

  async request(options: RequestOptions) {
    // 1. Check quota (existing static logic)
    BricklinkClient.recordQuotaUsage(); // No change

    // 2. Sign request using SHARED OAuth functions (refactored)
    const signature = await generateOAuthSignature(
      this.credentials, // From env
      method,
      url,
      params,
    );

    const authorization = buildAuthorizationHeader(this.credentials, signature, oauthParams);

    // 3. Make API call (no change)
    const response = await fetch(url, { headers: { Authorization: authorization } });

    return response;
  }

  // Keep existing: catalog methods (colors, categories, parts, price guides)
}

// Renamed singleton export to clarify purpose
export const catalogClient = new BricklinkClient();
```

[Source: docs/architecture/backend-architecture.md#catalog-data-refresh-lifecycle; docs/architecture/backend-architecture.md#internal-functions-server-only-building-blocks; docs/stories/3.1.user-marketplace-credentials-byok-on-settings.story.md#dev-notes]

### Database-Backed Rate Limiting Architecture

**Layer Responsibilities:**

1. **Client Layer** (`BricklinkStoreClient`) - Enforcement

   - Pre-flight quota check before each API request
   - Post-request quota recording after successful call
   - Throws structured error when quota exceeded

2. **Database Layer** (Convex mutations/queries in `marketplace.ts`)

   - Persistent quota state per business account
   - Atomic increment operations
   - Window reset logic (24-hour rolling)
   - Circuit breaker state tracking

3. **Orchestration Layer** (Story 3.4)
   - Handles rate limit errors gracefully
   - Schedules retries after quota resets
   - Updates UI with quota status

**Schema: marketplaceRateLimits Table**

```typescript
// convex/schema.ts - extend with rate limiting table
marketplaceRateLimits: defineTable({
  businessAccountId: v.id("businessAccounts"),
  provider: v.union(v.literal("bricklink"), v.literal("brickowl")),

  // Quota tracking
  windowStart: v.number(),           // Unix timestamp when current window started
  requestCount: v.number(),          // Requests made in current window
  capacity: v.number(),              // Max requests per window (5000 for BrickLink)
  windowDurationMs: v.number(),      // Window size in ms (86400000 = 24 hours)

  // Alerting
  alertThreshold: v.number(),        // Percentage (0-1) to trigger alert (default: 0.8)
  alertEmitted: v.boolean(),         // Whether alert has been sent for current window

  // Circuit breaker
  consecutiveFailures: v.number(),   // Track failures for circuit breaker
  circuitBreakerOpenUntil: v.optional(v.number()), // If set, circuit is open

  // Metadata
  lastRequestAt: v.number(),
  lastResetAt: v.number(),
  createdAt: v.number(),
  updatedAt: v.number(),
})
  .index("by_business_provider", ["businessAccountId", "provider"]),
```

**Implementation Pattern:**

```typescript
// Client pre-flight check
class BricklinkStoreClient {
  async request(options) {
    // 1. Check quota BEFORE making request
    const quota = await ctx.runQuery(internal.marketplace.getQuotaState, {
      businessAccountId: this.businessAccountId,
      provider: "bricklink",
    });

    // Check window reset
    const now = Date.now();
    const windowElapsed = now - quota.windowStart;
    const isWindowExpired = windowElapsed >= quota.windowDurationMs;

    // Check circuit breaker
    if (quota.circuitBreakerOpenUntil && now < quota.circuitBreakerOpenUntil) {
      throw new ConvexError({
        code: "CIRCUIT_BREAKER_OPEN",
        message: "BrickLink sync temporarily disabled due to repeated failures",
        retryAfterMs: quota.circuitBreakerOpenUntil - now,
      });
    }

    // Check quota (skip if window expired, will reset on increment)
    if (!isWindowExpired && quota.requestCount >= quota.capacity) {
      const resetIn = quota.windowStart + quota.windowDurationMs - now;
      throw new ConvexError({
        code: "RATE_LIMIT_EXCEEDED",
        message: `BrickLink rate limit exceeded (${quota.requestCount}/${quota.capacity}). Resets in ${Math.ceil(resetIn / 60000)} minutes.`,
        retryAfterMs: resetIn,
        currentUsage: quota.requestCount,
        capacity: quota.capacity,
      });
    }

    // 2. Make API request
    let response;
    try {
      response = await fetch(url, { ... });
    } catch (error) {
      // Record failure for circuit breaker
      await ctx.runMutation(internal.marketplace.recordFailure, {
        businessAccountId: this.businessAccountId,
        provider: "bricklink",
      });
      throw error;
    }

    // 3. Record quota usage AFTER successful request
    await ctx.runMutation(internal.marketplace.incrementQuota, {
      businessAccountId: this.businessAccountId,
      provider: "bricklink",
    });

    return response;
  }
}

// Database mutations
export const incrementQuota = internalMutation({
  args: { businessAccountId: v.id("businessAccounts"), provider: v.string() },
  handler: async (ctx, { businessAccountId, provider }) => {
    const now = Date.now();
    const existing = await ctx.db
      .query("marketplaceRateLimits")
      .withIndex("by_business_provider", q =>
        q.eq("businessAccountId", businessAccountId).eq("provider", provider)
      )
      .first();

    // Initialize if first request
    if (!existing) {
      await ctx.db.insert("marketplaceRateLimits", {
        businessAccountId,
        provider,
        windowStart: now,
        requestCount: 1,
        capacity: 5000, // BrickLink limit
        windowDurationMs: 86400000, // 24 hours
        alertThreshold: 0.8,
        alertEmitted: false,
        consecutiveFailures: 0,
        lastRequestAt: now,
        lastResetAt: now,
        createdAt: now,
        updatedAt: now,
      });
      return;
    }

    // Check if window expired
    const windowElapsed = now - existing.windowStart;
    if (windowElapsed >= existing.windowDurationMs) {
      // Reset window
      await ctx.db.patch(existing._id, {
        windowStart: now,
        requestCount: 1,
        alertEmitted: false,
        consecutiveFailures: 0, // Reset failures on new window
        lastRequestAt: now,
        lastResetAt: now,
        updatedAt: now,
      });
      return;
    }

    // Increment counter
    const newCount = existing.requestCount + 1;
    const percentage = newCount / existing.capacity;

    // Check alert threshold
    const shouldAlert = percentage >= existing.alertThreshold && !existing.alertEmitted;

    await ctx.db.patch(existing._id, {
      requestCount: newCount,
      alertEmitted: shouldAlert ? true : existing.alertEmitted,
      lastRequestAt: now,
      updatedAt: now,
    });

    // Emit alert metric
    if (shouldAlert) {
      recordMetric("external.bricklink.store.quota.alert", {
        businessAccountId,
        provider,
        count: newCount,
        capacity: existing.capacity,
        percentage,
      });
    }
  },
});

export const getQuotaState = internalQuery({
  args: { businessAccountId: v.id("businessAccounts"), provider: v.string() },
  handler: async (ctx, { businessAccountId, provider }) => {
    const quota = await ctx.db
      .query("marketplaceRateLimits")
      .withIndex("by_business_provider", q =>
        q.eq("businessAccountId", businessAccountId).eq("provider", provider)
      )
      .first();

    // Return defaults if no quota record exists
    if (!quota) {
      return {
        windowStart: Date.now(),
        requestCount: 0,
        capacity: 5000,
        windowDurationMs: 86400000,
        alertThreshold: 0.8,
        alertEmitted: false,
        consecutiveFailures: 0,
        circuitBreakerOpenUntil: undefined,
      };
    }

    return quota;
  },
});

export const recordFailure = internalMutation({
  args: { businessAccountId: v.id("businessAccounts"), provider: v.string() },
  handler: async (ctx, { businessAccountId, provider }) => {
    const existing = await ctx.db
      .query("marketplaceRateLimits")
      .withIndex("by_business_provider", q =>
        q.eq("businessAccountId", businessAccountId).eq("provider", provider)
      )
      .first();

    if (!existing) return; // No quota record yet

    const newFailures = existing.consecutiveFailures + 1;
    const now = Date.now();

    // Open circuit breaker after 5 consecutive failures
    const updates: any = {
      consecutiveFailures: newFailures,
      updatedAt: now,
    };

    if (newFailures >= 5) {
      updates.circuitBreakerOpenUntil = now + (5 * 60 * 1000); // 5 minutes

      recordMetric("external.bricklink.store.circuit_breaker.open", {
        businessAccountId,
        provider,
        consecutiveFailures: newFailures,
      });
    }

    await ctx.db.patch(existing._id, updates);
  },
});
```

**Why Database-Backed:**

- ✅ Persistent across Convex isolate restarts
- ✅ Shared state across distributed backend instances
- ✅ Enables future UI quota dashboard
- ✅ Audit trail for debugging
- ✅ Supports per-tenant (business account) isolation
- ✅ Circuit breaker state persists

**Performance Considerations:**

- Pre-flight check is a fast indexed query (< 5ms)
- Post-request increment is single atomic write
- Circuit breaker prevents wasted API calls when service is down
- Alert threshold prevents metric spam

[Source: docs/architecture/backend-architecture.md#convex-function-patterns-and-best-practices; docs/prd/epic-3-inventory-management.md#story-32]

### Bulk Operations Strategy for API Efficiency

**BrickLink API Bulk Capabilities:**

BrickLink provides **native bulk support for CREATE only**. This has significant implications for API quota management:

| Operation       | Native Bulk?    | API Calls for 100 Items | Efficiency         |
| --------------- | --------------- | ----------------------- | ------------------ |
| **CREATE**      | ✅ Yes          | **1 call**              | **100x efficient** |
| **UPDATE**      | ❌ No           | 100 calls               | Standard           |
| **DELETE**      | ❌ No           | 100 calls               | Standard           |
| **READ (list)** | ✅ Yes (filter) | 1 call                  | Efficient          |

**Critical Efficiency Pattern:**

```typescript
// ✅ HIGHLY EFFICIENT - Native bulk create (1 API call)
await client.createInventories([
  { item: { no: "3001", type: "PART" }, color_id: 1, quantity: 10, ... },
  { item: { no: "3002", type: "PART" }, color_id: 2, quantity: 5, ... },
  // ... 100 items
]); // Single POST /inventories with array body

// ❌ INEFFICIENT - Individual creates (100 API calls)
for (const item of items) {
  await client.createInventory(item); // 100 separate POST calls
}
```

**Implementation Requirements:**

1. **Bulk Create** (Task 2 + 4):

   - Use native `POST /inventories` with array body
   - Chunk size: 100 items (BrickLink recommended maximum)
   - Critical for Story 3.4 initial sync: syncing 1,000 inventory items = **10 API calls** instead of 1,000
   - Response: `{ meta, data: null }` (no individual IDs returned in bulk response)
   - **ID Tracking Strategy**: After bulk create, call `GET /inventories` and match items by unique key (partNumber + colorId + condition) to populate `bricklinkLotId` in Convex
   - **Trade-off**: Bulk create (10 calls) + fetch IDs (1 call) = 11 total calls vs 1,000 individual creates - still **90x more efficient**

2. **Bulk Update** (Task 4):

   - No native support - must sequence individual `PUT /inventories/{id}` calls
   - Chunk size: 50 items with inter-chunk delay (100ms) to smooth rate limiting
   - Progress tracking essential for long-running updates

3. **Bulk Delete** (Task 4):
   - No native support - must sequence individual `DELETE /inventories/{id}` calls
   - Chunk size: 50 items with progress tracking

**Rate Limit Impact:**

Given BrickLink's 5,000 requests/day quota per account:

- **Bulk Create**: Can sync 500,000 new items/day (100 items × 5,000 calls)
- **Bulk Update**: Can update 5,000 items/day (1 item × 5,000 calls)
- **Bulk Delete**: Can delete 5,000 items/day (1 item × 5,000 calls)

**Story 3.4 Integration - Initial Sync Optimization:**

When user first connects BrickLink, Story 3.4 should use this efficient pattern:

```typescript
// Efficient initial sync pattern with ID tracking

// Option 1: Pull from BrickLink → Convex (import existing inventory)
const bricklinkInventories = await client.getInventories(); // 1 API call (gets all)
await bulkImportToConvex(bricklinkInventories.map(mapBricklinkToConvexInventory)); // All inventory IDs already present in response

// Option 2: Push from Convex → BrickLink (export local to marketplace)
const convexInventories = await getAllLocalInventories();

// Step 1: Bulk create on BrickLink (highly efficient)
await client.bulkCreateInventories(convexInventories.map(mapConvexToBricklinkInventory), {
  chunkSize: 100,
  onProgress: (p) => updateUI(p),
}); // ~10 API calls for 1000 items

// Step 2: Fetch BrickLink IDs to enable future syncing (1 additional call)
const createdInventories = await client.getInventories(); // 1 API call

// Step 3: Match and update Convex records with BrickLink IDs
for (const bricklinkItem of createdInventories) {
  const convexItem = findMatchingConvexItem(
    bricklinkItem.item.no, // partNumber
    bricklinkItem.color_id, // colorId
    bricklinkItem.new_or_used, // condition
  );

  if (convexItem) {
    await updateConvexWithBricklinkId(convexItem._id, bricklinkItem.inventory_id);
  }
}

// Total: ~11 API calls for 1000 items (still 90x more efficient than individual creates)
```

**Matching Strategy for Bulk Create ID Resolution:**

Create unique composite key from: `${partNumber}-${colorId}-${condition}`

```typescript
// Build lookup map from BrickLink results
const bricklinkMap = new Map(
  createdInventories.map((item) => [
    `${item.item.no}-${item.color_id}-${item.new_or_used}`,
    item.inventory_id,
  ]),
);

// Match Convex items to BrickLink IDs
for (const convexItem of convexInventories) {
  const key = `${convexItem.partNumber}-${convexItem.colorId}-${convexItem.condition === "new" ? "N" : "U"}`;
  const bricklinkId = bricklinkMap.get(key);

  if (bricklinkId) {
    convexItem.bricklinkLotId = bricklinkId;
  }
}
```

**Edge Case - Duplicate Parts:**

If user has multiple lots of same part-color-condition combination:

- BrickLink allows duplicate inventory lots (same part, different prices/locations)
- Matching by composite key may be ambiguous
- Story 3.4 should handle: match by additional fields (price, quantity, date) or use individual creates for better tracking

````

**Key Principles:**

- ✅ **Always use bulk create** when adding multiple items
- ✅ **Batch updates/deletes** to show progress and handle partial failures
- ✅ **Monitor quota usage** - track API calls consumed, not just items processed
- ✅ **Provide progress feedback** - especially for sequential operations
- ✅ **Handle partial failures gracefully** - continue processing remaining items

[Source: docs/external-documentation/api-bricklink/inventory.md#create-store-inventories; docs/prd/epic-3-inventory-management.md#story-32; docs/prd/epic-3-inventory-management.md#story-34]

### Data Models

**BrickLink Inventory API Response Shape:**

```typescript
interface BricklinkInventoryResponse {
  inventory_id: number;
  item: {
    no: string; // Part number
    name: string;
    type:
      | "PART"
      | "SET"
      | "MINIFIG"
      | "BOOK"
      | "GEAR"
      | "CATALOG"
      | "INSTRUCTION"
      | "UNSORTED_LOT"
      | "ORIGINAL_BOX";
    category_id: number;
  };
  color_id: number;
  color_name: string;
  quantity: number;
  new_or_used: "N" | "U"; // N = New, U = Used
  completeness?: "C" | "B" | "S"; // C = Complete, B = Incomplete, S = Sealed (SET only)
  unit_price: string; // Fixed point number as string (e.g., "1.2000")
  bind_id: number;
  description: string;
  remarks: string;
  bulk: number; // Buyers can buy only in multiples of this amount
  is_retain: boolean; // Retains in inventory after sold out
  is_stock_room: boolean; // Only in owner's inventory (not public)
  stock_room_id?: "A" | "B" | "C";
  date_created: string; // ISO timestamp
  my_cost?: string; // Fixed point number
  sale_rate?: number; // Sale percentage (e.g., 20 for 20% off)
  tier_quantity1?: number;
  tier_price1?: string;
  tier_quantity2?: number;
  tier_price2?: string;
  tier_quantity3?: number;
  tier_price3?: string;
}
````

[Source: docs/external-documentation/api-bricklink/inventory.md]

**Convex inventoryItems Schema (Target Mapping):**

```typescript
{
  businessAccountId: Id<"businessAccounts">;
  sku: string; // Derived from partNumber + colorId + condition
  name: string;
  partNumber: string; // Maps from item.no
  colorId: string; // Maps from color_id (stored as string)
  location: string; // Maps from stock_room_id or custom field
  quantityAvailable: number; // Maps from quantity
  quantityReserved: number;
  quantitySold: number;
  status: "available" | "reserved" | "sold";
  condition: "new" | "used"; // Maps from new_or_used: "N" → "new", "U" → "used"
  price?: number; // Maps from unit_price (parse string to number)
  notes?: string; // Maps from description or remarks
  bricklinkLotId?: number; // Maps from inventory_id (track BrickLink sync)
  createdBy: Id<"users">;
  createdAt: number;
  updatedAt?: number;
  isArchived?: boolean;
  deletedAt?: number;
}
```

[Source: docs/architecture/database-schema.md#inventoryitems; docs/architecture/data-models.md#inventoryitem]

**Mapping Strategy:**

- **Quantity Delta Pattern**: BrickLink requires quantity updates as deltas ("+5", "-3"), not absolute values. When syncing from Convex → BrickLink, calculate delta from previous known quantity.
- **Stock Room → Location**: BrickLink uses `is_stock_room` boolean + `stock_room_id` enum; map to our flexible `location` string field (e.g., "Stockroom A", "Stockroom B", or custom locations).
- **SKU Generation**: Create unique SKU from `partNumber-colorId-condition` (e.g., "3001-5-new") for duplicate prevention.
- **Sync Tracking**: Store `bricklinkLotId` in our schema to track which Convex inventory items are synced to BrickLink and enable bidirectional updates.

[Source: docs/external-documentation/api-bricklink/inventory.md#update-store-inventory; docs/prd/epic-3-inventory-management.md#story-32]

### API Specifications

**BrickLink Inventory Endpoints:**

```typescript
// List inventories (bulk read)
GET /inventories?item_type={type}&status={status}&category_id={id}&color_id={id}
Response: { meta, data: BricklinkInventoryResponse[] }
Note: Returns all matching inventories - efficient for initial sync

// Get single inventory
GET /inventories/{inventory_id}
Response: { meta, data: BricklinkInventoryResponse }

// Create single inventory
POST /inventories
Body: { item: { no, type }, color_id, quantity, unit_price, new_or_used, ... }
Response: { meta, data: BricklinkInventoryResponse }

// ⭐ Create multiple inventories (NATIVE BULK - HIGHLY EFFICIENT)
POST /inventories
Body: [{ item: { no, type }, ... }, { item: { no, type }, ... }, ...]
Response: { meta, data: null } // Returns empty data on success
Note: 100 items = 1 API call - use this for Story 3.4 initial bulk sync!

// Update single inventory (NO BULK SUPPORT - must loop)
PUT /inventories/{inventory_id}
Body: { quantity: "+5", unit_price: "1.50", ... } // Quantity MUST be delta with +/- prefix
Response: { meta, data: BricklinkInventoryResponse }
Note: BrickLink does not support bulk update - 100 updates = 100 API calls

// Delete single inventory (NO BULK SUPPORT - must loop)
DELETE /inventories/{inventory_id}
Response: { meta, data: null }
Note: BrickLink does not support bulk delete - 100 deletes = 100 API calls
```

**Critical API Constraints:**

- Quantity updates MUST use delta syntax: `"+10"` to add, `"-5"` to subtract
- Tier pricing requires all 6 fields to be present (tier_quantity1-3, tier_price1-3)
- `completeness` field only valid for item type "SET"
- All price fields are fixed-point strings (e.g., "1.2000")
- Status parameter uses single letters: "Y" (available), "S"/"B"/"C" (stockroom), "N" (unavailable), "R" (reserved)

**Bulk Create Limitation:**

- Native bulk create (`POST /inventories` with array) returns `{ meta, data: null }` - **does NOT return inventory IDs**
- To get BrickLink inventory IDs after bulk create, must call `GET /inventories` to fetch and match by part number + color + condition
- Alternative: Use individual creates when inventory IDs are needed immediately (trade efficiency for ID tracking)
- Story 3.4 should handle this: bulk create for initial sync, then query to populate `bricklinkLotId` fields in Convex

[Source: docs/external-documentation/api-bricklink/inventory.md#create-store-inventories]

### Component Specifications

N/A - This story is backend-only (no frontend components).

### File Locations

**Backend:**

- **Shared OAuth**: `convex/bricklink/oauth.ts` (new file - pure OAuth 1.0a signing functions extracted from existing client)
- **Catalog Client** (Story 2.3): `convex/bricklink/catalogClient.ts` (renamed from `bricklinkClient.ts`, refactored to use shared OAuth helpers, export renamed to `catalogClient` - **NO breaking changes to functionality**)
- **Store Client** (This Story): `convex/bricklink/storeClient.ts` (new file - uses shared OAuth + DB rate limiting for store operations)
- **Store Mappers**: `convex/bricklink/storeMappers.ts` (new file - bidirectional BrickLink store ↔ Convex mapping, handles inventory now + orders in Epic 4)
- **Marketplace Functions**: `convex/functions/marketplace.ts` (extend with `createBricklinkStoreClient()` factory + rate limiting mutations/queries)
- **Marketplace Types**: `convex/marketplaces/types.ts` (new file - shared interfaces across all marketplace providers)
- **Schema**: `convex/schema.ts` (add `marketplaceRateLimits` table)

**Tests:**

- OAuth Functions: `__tests__/backend/bricklink-oauth.test.ts` (test extracted OAuth logic)
- Store Client: `__tests__/backend/bricklink-store-client.test.ts` (test store CRUD + rate limiting)
- Store Mappers: `__tests__/backend/bricklink-store-mappers.test.ts` (test bidirectional mapping)
- Catalog Client Refactor: Update `__tests__/backend/bricklink-client.test.ts` if it exists (verify no breaking changes)

[Source: docs/architecture/unified-project-structure.md; docs/architecture/testing-strategy.md#test-organization]

### Technical Constraints

**OAuth 1.0a Signing (User Credentials):**

- Reuse existing OAuth implementation from `BricklinkClient` but parameterize with user credentials
- Extract signing logic to shared `oauth.ts` module for DRY principle
- User credentials stored encrypted; must decrypt at runtime using `decryptCredential()` from Story 3.1
- NEVER log credential values or Authorization headers in any logs/metrics

**Quantity Delta Syntax:**

- BrickLink API requires quantity updates as strings with +/- prefix (e.g., `"+5"`, `"-3"`)
- This prevents race conditions when quantity changes between read and update
- Always calculate delta from last known quantity; never send absolute quantity values
- Create inventories can use absolute quantity (no prefix), updates MUST use delta

**Rate Limiting and Quota (Database-Backed):**

- **Architecture**: Database-backed quota tracking using `marketplaceRateLimits` Convex table
- **Isolation**: User inventory operations have separate quota from BrickOps catalog operations; each business account has independent rate limit (BrickLink enforces per API credential)
- **Enforcement**: Client layer performs pre-flight quota check and post-request recording via internal mutations/queries
- **Persistence**: Quota state persists across restarts and is shared across all Convex backend instances
- **Circuit Breaker**: Track consecutive failures; temporarily disable sync after 5 failures to prevent account suspension
- **Alerting**: Emit metric at 80% threshold; reset alert flag when window resets
- **HTTP 429 Handling**: Respect BrickLink's `Retry-After` header; calculate retry time from quota window
- **Window Reset**: 24-hour rolling window with automatic reset logic in `incrementQuota` mutation
- **Future UI**: Quota state queryable for Settings page dashboard ("2,847 / 5,000 requests used today")

**Idempotency:**

- Generate request key (hash of payload) to dedupe bulk operations within same batch
- Support external idempotency keys via `options.idempotencyKey` - Story 3.4 will pass change log IDs
- NEVER auto-retry non-idempotent operations (POST create) - only safe operations (GET, PUT, DELETE)
- For bulk creates, if partial failure occurs, return detailed error report with failed items and allow manual retry

**Structured Result Format (for Story 3.4 Integration):**

All CRUD operations return standardized result format for sync status tracking:

```typescript
// Defined in convex/marketplaces/types.ts
interface StoreOperationResult {
  success: boolean;
  bricklinkLotId?: number; // For inventory create/update/get operations
  bricklinkOrderId?: number; // For order operations (Epic 4)
  error?: {
    code: string; // e.g., "CONFLICT", "VALIDATION_ERROR", "RATE_LIMIT", "NOT_FOUND"
    message: string; // User-friendly error message
    details?: any; // Additional error context
  };
  marketplaceStatus?: string; // BrickLink's status field if available
  correlationId: string; // For tracing
}
```

This enables Story 3.4 to:

- Track sync status per change (`success` flag)
- Update Convex records with BrickLink IDs (`bricklinkLotId`)
- Detect conflicts for UI display (`error.code === "CONFLICT"`)
- Provide detailed error messages to users (`error.message`)

**Note:** Interface is generic "Store" operation to support both inventory (Story 3.2) and orders (Epic 4).

[Source: docs/external-documentation/api-bricklink/authentication.md; docs/external-documentation/api-bricklink/inventory.md; docs/architecture/backend-architecture.md#actions-external-api-orchestration; docs/prd/epic-3-inventory-management.md#story-34]

### Error Handling

**Backend:**

- Use `ConvexError` for user-facing errors with helpful messages:
  - "BrickLink credentials not configured" → guide to settings page
  - "BrickLink API rate limit exceeded" → show retry-after time
  - "Invalid inventory data" → show which fields failed validation
- Use `normalizeApiError()` helper from `convex/lib/external/types.ts` for consistent error formatting
- Log all errors server-side with correlation ID but return safe messages to client
- Handle BrickLink API errors gracefully:
  - HTTP 400 (Bad Request) → validation error, surface field-level details
  - HTTP 401 (Unauthorized) → credentials expired/invalid, prompt user to re-authenticate
  - HTTP 404 (Not Found) → inventory item doesn't exist on BrickLink
  - HTTP 429 (Too Many Requests) → rate limit, show wait time
  - HTTP 500 (Server Error) → transient failure, retry with backoff

**Bulk Operation Error Handling:**

- Track partial failures with detailed context: `{ batchIndex, itemIndex, item, error }`
- Return comprehensive result: `{ succeeded: number, failed: number, errors: Array<...> }`
- Allow caller to decide whether to retry failed items or surface errors to user
- Log bulk operation summary: `{ correlationId, totalItems, succeeded, failed, durationMs }`

[Source: docs/architecture/error-handling-strategy.md; docs/architecture/backend-architecture.md#function-template; docs/prd/epic-3-inventory-management.md#story-32]

### Security Considerations

**Credential Protection:**

- User marketplace credentials decrypted only server-side in actions (never exposed to client)
- Use `internal` actions for client creation - NEVER expose credential retrieval as public API
- RBAC enforcement: only owner role can trigger inventory sync operations
- All API requests log correlation ID but NEVER log credential values, auth headers, or sensitive data

**Tenant Isolation:**

- All operations require `businessAccountId` parameter
- Verify user belongs to business account before creating inventory client
- Rate limiting tracked per business account (separate quota per tenant)
- Never expose one tenant's BrickLink data to another tenant

**Rate Limiting:**

- Respect BrickLink's rate limits to avoid account suspension
- Implement circuit breaker: disable sync for account after repeated failures
- Surface clear error messages to users when rate limited (don't expose technical details)

[Source: docs/architecture/security-and-performance.md#security-requirements; docs/architecture/backend-architecture.md#authentication-and-authorization]

### Integration with Story 3.1 (Marketplace Credentials)

**Credential Retrieval and Client Factory Pattern:**

```typescript
// convex/functions/marketplace.ts
export const createBricklinkStoreClient = internalAction({
  args: { businessAccountId: v.id("businessAccounts") },
  handler: async (ctx, { businessAccountId }) => {
    // 1. Query marketplace credentials
    const credentials = await ctx.runQuery(internal.marketplace.getEncryptedCredentials, {
      businessAccountId,
      provider: "bricklink",
    });

    if (!credentials || !credentials.isActive) {
      throw new ConvexError("BrickLink credentials not configured");
    }

    // 2. Decrypt credentials
    const decryptedCreds = {
      consumerKey: await decryptCredential(credentials.bricklinkConsumerKey),
      consumerSecret: await decryptCredential(credentials.bricklinkConsumerSecret),
      tokenValue: await decryptCredential(credentials.bricklinkTokenValue),
      tokenSecret: await decryptCredential(credentials.bricklinkTokenSecret),
    };

    // 3. Create and return client with ActionCtx for DB rate limiting
    // CRITICAL: Pass ctx so client can call internal queries/mutations for quota tracking
    return new BricklinkStoreClient(
      decryptedCreds,
      businessAccountId,
      ctx, // ActionCtx enables DB-backed rate limiting
    );
  },
});
```

**Why ActionCtx is Required:**

The store client needs `ActionCtx` to:

- Call `ctx.runQuery(internal.marketplace.getQuotaState, ...)` for pre-flight quota checks
- Call `ctx.runMutation(internal.marketplace.incrementQuota, ...)` for post-request recording
- Call `ctx.runMutation(internal.marketplace.recordFailure, ...)` for circuit breaker tracking

This is why the client is instantiated **inside an action**, not as a singleton like the catalog client.

[Source: docs/stories/3.1.user-marketplace-credentials-byok-on-settings.story.md#dev-notes; docs/architecture/backend-architecture.md#internal-functions-server-only-building-blocks]

### Integration with Story 3.4 (Orchestration Layer)

Story 3.4 will consume this client to sync inventory changes. Here are the key integration patterns:

**Pattern 1: Per-Change Sync (Story 3.4 Change Log Processing)**

```typescript
// Story 3.4 sync action will process change log entries one at a time
export const syncInventoryChange = internalAction({
  args: { changeId: v.id("inventoryChangeLog") },
  handler: async (ctx, { changeId }) => {
    // Get change details
    const change = await ctx.runQuery(internal.inventory.getChange, { changeId });

    // Create client
    const client = await ctx.runAction(internal.marketplace.createBricklinkStoreClient, {
      businessAccountId: change.businessAccountId,
    });

    // Execute sync with idempotency key (change ID)
    let result;
    switch (change.changeType) {
      case "create":
        result = await client.createInventory(change.newData, {
          idempotencyKey: changeId,
        });
        break;
      case "update":
        result = await client.updateInventory(change.bricklinkLotId, change.delta, {
          idempotencyKey: changeId,
        });
        break;
      case "delete":
        result = await client.deleteInventory(change.bricklinkLotId, {
          idempotencyKey: changeId,
        });
        break;
    }

    // Update sync status
    await ctx.runMutation(internal.inventory.updateSyncStatus, {
      changeId,
      provider: "bricklink",
      success: result.success,
      bricklinkLotId: result.bricklinkLotId,
      error: result.error,
      syncedAt: Date.now(),
    });
  },
});
```

**Pattern 2: Bulk Initial Sync (Story 3.4 First-Time Setup)**

```typescript
// Story 3.4 will support bulk initial sync when user first connects BrickLink
export const initialBulkSync = internalAction({
  args: { businessAccountId: v.id("businessAccounts") },
  handler: async (ctx, { businessAccountId }) => {
    const client = await ctx.runAction(internal.marketplace.createBricklinkStoreClient, {
      businessAccountId,
    });

    // Pull all BrickLink inventory
    const bricklinkInventories = await client.getInventories();

    // Bulk import to Convex with progress tracking
    const results = await ctx.runMutation(internal.inventory.bulkImportFromBricklink, {
      businessAccountId,
      inventories: bricklinkInventories.map(mapBricklinkToConvexInventory),
    });

    return { imported: results.succeeded, failed: results.failed };
  },
});
```

**Pattern 3: Rollback Support (Story 3.4 AC 3.4.7)**

```typescript
// Story 3.4 will support rolling back inventory changes
export const rollbackChange = internalAction({
  args: { changeId: v.id("inventoryChangeLog") },
  handler: async (ctx, { changeId }) => {
    const change = await ctx.runQuery(internal.inventory.getChange, { changeId });
    const client = await ctx.runAction(internal.marketplace.createBricklinkStoreClient, {
      businessAccountId: change.businessAccountId,
    });

    // Execute compensating operation
    let compensatingResult;
    switch (change.changeType) {
      case "create":
        // Rollback create = delete
        compensatingResult = await client.deleteInventory(change.bricklinkLotId, {
          idempotencyKey: `rollback-${changeId}`,
        });
        break;
      case "update":
        // Rollback update = update with previous values
        compensatingResult = await client.updateInventory(
          change.bricklinkLotId,
          change.previousData,
          { idempotencyKey: `rollback-${changeId}` },
        );
        break;
      case "delete":
        // Rollback delete = recreate
        compensatingResult = await client.createInventory(change.previousData, {
          idempotencyKey: `rollback-${changeId}`,
        });
        break;
    }

    // Record rollback in change log
    await ctx.runMutation(internal.inventory.recordRollback, {
      originalChangeId: changeId,
      compensatingResult,
    });
  },
});
```

**Pattern 4: Conflict Detection (Story 3.4 AC 3.4.5)**

```typescript
// Story 3.4 handles conflicts when BrickLink rejects updates
if (!result.success && result.error?.code === "CONFLICT") {
  // Surface to UI: "Inventory on BrickLink was modified externally"
  await ctx.runMutation(internal.inventory.markConflict, {
    changeId,
    conflictDetails: result.error.details,
  });
}
```

**Key Requirements for Story 3.4 Integration:**

1. ✅ Client supports per-operation calls (not just bulk)
2. ✅ Client accepts external idempotency keys (change IDs)
3. ✅ Client returns structured results for sync status tracking
4. ✅ Client supports rollback via inverse operations
5. ✅ Client provides detailed error responses for conflict handling
6. ✅ Client includes correlation IDs for tracing through sync pipeline

[Source: docs/prd/epic-3-inventory-management.md#story-34; docs/architecture/backend-architecture.md#internal-functions-server-only-building-blocks]

### Testing Approach

**Unit Tests (Vitest):**

- Mock HTTP requests using test factories
- Mock `crypto` functions for deterministic OAuth signing tests
- Verify mapper functions with comprehensive fixtures covering all BrickLink field variations
- Test quota tracking, backoff logic, error normalization in isolation

**Integration Tests (Future - Story 3.4):**

- Story 3.4 (Convex Orchestration Layer) will add integration tests for end-to-end sync flows
- Will test: Convex → BrickLink sync, BrickLink → Convex sync, conflict resolution, rollback scenarios

**HTTP Mocking Pattern:**

```typescript
// Mock fetch for deterministic tests
global.fetch = jest.fn((url, options) => {
  if (url.includes("/inventories")) {
    return Promise.resolve({
      ok: true,
      status: 200,
      headers: new Headers(),
      json: async () => ({ meta: {}, data: mockBricklinkInventoryResponse }),
    });
  }
  throw new Error(`Unmocked endpoint: ${url}`);
});
```

[Source: docs/architecture/testing-strategy.md#backend-tests; docs/architecture/coding-standards.md#testing-standards]

## Change Log

| Date       | Version | Description                                                                                                                                                                 | Author |
| ---------- | ------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------ |
| 2025-10-09 | v1.0    | Initial draft of Story 3.2                                                                                                                                                  | Bob    |
| 2025-10-09 | v1.1    | Enhanced for Story 3.4 integration: added idempotency keys, structured results, rollback support, and comprehensive usage patterns                                          | Bob    |
| 2025-10-09 | v1.2    | Added database-backed rate limiting: marketplaceRateLimits table, per-tenant quota tracking, circuit breaker, detailed implementation patterns                              | Bob    |
| 2025-10-09 | v1.3    | Clarified bulk operation efficiency: emphasized native bulk CREATE (100x efficient), documented ID tracking strategy, noted UPDATE/DELETE are single-item only              | Bob    |
| 2025-10-09 | v1.4    | Clarified separate specialized clients architecture: catalog vs inventory, shared OAuth extraction, refactoring strategy, comprehensive class structures and usage patterns | Bob    |
| 2025-10-09 | v1.5    | Renamed to "Store" pattern: BricklinkStoreClient for inventory + future orders, added directory structure, updated all references to use store terminology                  | Bob    |

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4.5 (Developer Agent "James")

### Debug Log References

- No errors encountered during Tasks 1-7, 9-10 implementation (Task 8 skipped as requested)
- All linting checks passed
- TypeScript types aligned with BrickLink API documentation
- Schema extended with BrickLink sync fields (partNumber, price, notes, bricklinkLotId)
- Bulk operations implement proper chunking, progress tracking, and idempotency
- Database-backed rate limiting fully operational with alert metrics
- Exponential backoff and retry logic implemented with smart retry detection
- Comprehensive metrics and logging in place with correlation IDs, no credentials logged
- Client factory with secure credential decryption ready for Story 3.4
- Rollback support and dry-run mode implemented for inventoryAuditLogs integration

### Completion Notes List

**Task 1: Refactor OAuth signing and create specialized inventory client**

- Created `convex/bricklink/oauth.ts` with shared OAuth 1.0a signing functions:

  - `percentEncode()` - RFC 3986 compliant percent encoding
  - `generateOAuthParams()` - OAuth timestamp and nonce generation
  - `generateOAuthSignature()` - HMAC-SHA1 signature generation
  - `buildAuthorizationHeader()` - OAuth Authorization header construction
  - All functions are pure and accept credentials as parameters for testability

- Refactored `convex/bricklink/catalogClient.ts` (renamed from `bricklinkClient.ts`) to use shared OAuth module:

  - Removed inline OAuth logic
  - Updated request() method to use shared OAuth functions
  - Renamed export from `bricklinkClient` to `catalogClient` to clarify purpose
  - Maintained backward compatibility - no breaking changes to existing catalog methods
  - Kept static in-memory quota tracking (appropriate for singleton catalog client)

- Created `convex/bricklink/storeClient.ts` with database-backed rate limiting:

  - Accepts user credentials, businessAccountId, and ActionCtx in constructor
  - Implements pre-flight quota check and post-request quota recording
  - Implements circuit breaker pattern (opens after 5 consecutive failures)
  - Throws structured errors with correlation IDs for tracing
  - Validates credentials on construction
  - Records metrics for observability

- Extended `convex/functions/marketplace.ts` with rate limiting infrastructure:

  - Added `getQuotaState()` internal query for pre-flight checks
  - Added `incrementQuota()` internal mutation for post-request recording
  - Added `recordFailure()` internal mutation for circuit breaker tracking
  - Added `resetFailures()` internal mutation for success recovery
  - Added `createBricklinkStoreClient()` helper function for client factory pattern

- Updated `convex/schema.ts` with `marketplaceRateLimits` table:
  - Per-business-account quota tracking
  - Circuit breaker state management
  - 24-hour rolling window with automatic reset
  - 80% alert threshold configuration

**Task 2: Implement inventory lot CRUD operations**

- Added TypeScript interfaces to `convex/bricklink/storeClient.ts`:

  - `BricklinkApiResponse<T>` - Generic wrapper for BrickLink API responses
  - `BricklinkItemType` - Union type for item types (PART, SET, MINIFIG, etc.)
  - `BricklinkInventoryResponse` - Complete inventory response structure matching BrickLink API
  - `BricklinkInventoryCreateRequest` - Request payload for creating inventory
  - `BricklinkInventoryUpdateRequest` - Request payload for updating inventory with delta quantity
  - `GetInventoriesOptions` - Filter options for listing inventories

- Implemented CRUD methods in `BricklinkStoreClient`:

  - `getInventories(options?)` - List inventories with optional filters (item type, status, category, color)
  - `getInventory(inventoryId)` - Get single inventory by ID
  - `createInventory(payload)` - Create single inventory lot
  - `createInventories(payloads[])` - Native bulk create (100 items = 1 API call)
  - `updateInventory(inventoryId, payload)` - Update inventory with validation for +/- quantity syntax
  - `deleteInventory(inventoryId)` - Delete single inventory lot

- Implemented critical validation:
  - Update method validates quantity uses delta syntax with regex: `/^[+-]\d+$/`
  - Throws `INVALID_QUANTITY_FORMAT` error if quantity doesn't have +/- prefix
  - Prevents common mistake of passing absolute values instead of deltas

**Task 3: Implement data mappers for BrickLink <-> Convex schema**

- Extended `convex/schema.ts` inventoryItems table with BrickLink sync fields:

  - `partNumber` - BrickLink part number (item.no)
  - `price` - Unit price for marketplace sync (optional)
  - `notes` - Description/remarks from marketplace (optional)
  - `bricklinkLotId` - BrickLink inventory_id for sync tracking (optional)
  - Added index `by_bricklinkLotId` for efficient lookups

- Created `convex/bricklink/storeMappers.ts` with bidirectional mappers:
  - `ConvexInventoryItem` type - TypeScript interface for Convex inventory
  - `mapBricklinkToConvexInventory()` - Import from BrickLink to Convex:
    - Maps all BrickLink fields to Convex schema
    - Converts condition: "N" → "new", "U" → "used"
    - Parses location from stockroom fields (Stockroom A/B/C)
    - Generates SKU from partNumber-colorId-condition
    - Parses fixed-point price string to number
    - Combines description + remarks into notes field
    - Sets defaults: quantityReserved=0, quantitySold=0, status="available"
  - `mapConvexToBricklinkCreate()` - Export to BrickLink create:
    - Converts condition: "new" → "N", "used" → "U"
    - Parses location to stockroom flags (is_stock_room, stock_room_id)
    - Formats price as fixed-point string (4 decimals)
    - Sets sensible defaults: bulk=1, is_retain=false, type="PART"
  - `mapConvexToBricklinkUpdate()` - Export to BrickLink update:
    - Calculates quantity delta with proper +/- prefix
    - Only includes fields being updated
    - Handles optional previousQuantity for delta calculation
  - `calculateQuantityDelta()` - Helper for delta calculation
  - `validateBricklinkCreate()` - Pre-create validation:
    - Validates all required fields present
    - Checks enum values (condition, completeness, item type)
    - Ensures quantity is non-negative
  - `validateBricklinkUpdate()` - Pre-update validation:
    - Validates quantity uses +/- delta syntax
    - Checks price format

**Task 4: Implement bulk operations with chunking**

- Added bulk operation types to `convex/bricklink/storeClient.ts`:

  - `BulkProgress` - Progress callback interface with completed/total/batch tracking
  - `BulkOperationOptions` - Configuration for chunk size, progress callbacks, idempotency keys, delays
  - `BulkOperationItemResult` - Per-item result with success/error/correlationId
  - `BulkOperationResult` - Summary with succeeded/failed counts and detailed error array

- Implemented `bulkCreateInventories()` - Native bulk API (HIGHLY EFFICIENT):

  - Uses BrickLink's native bulk create API (100 items = 1 API call)
  - Default chunk size: 100 items per batch
  - Progress tracking with callbacks after each batch
  - Partial failure handling: batch failures recorded for all items in failed batch
  - Idempotency support: external keys + deduplication within operation
  - Note: BrickLink returns null data (no IDs) - Story 3.4 will query after to get IDs

- Implemented `bulkUpdateInventories()` - Sequential API calls (no native support):

  - Sequences individual PUT requests (100 updates = 100 API calls)
  - Default chunk size: 50 items per batch
  - Default inter-batch delay: 100ms to smooth rate limiting
  - Per-item error tracking with detailed context
  - Progress tracking with callbacks
  - Idempotency: skips already-processed items by inventory ID
  - Continues processing remaining items on individual failures

- Implemented `bulkDeleteInventories()` - Sequential API calls (no native support):

  - Sequences individual DELETE requests (100 deletes = 100 API calls)
  - Default chunk size: 50 items per batch
  - Default inter-batch delay: 100ms to smooth rate limiting
  - Per-item error tracking with detailed context
  - Progress tracking and idempotency support
  - Continues processing remaining items on individual failures

- Added helper methods:

  - `chunkArray<T>()` - Splits arrays into smaller chunks
  - `sleep()` - Async delay for inter-batch rate limit smoothing

- Key features implemented:
  - ✅ Progress callbacks for UI feedback (completed/total/batch numbers)
  - ✅ Comprehensive error tracking (batch index, item index, error details)
  - ✅ Idempotency support (external keys from Story 3.4 + internal deduplication)
  - ✅ Partial failure recovery (continue processing on errors)
  - ✅ Structured results for Story 3.4 sync status tracking
  - ✅ Rate limit optimization (configurable delays between batches)
  - ✅ Correlation IDs for distributed tracing

**Task 5: Database-backed rate limiting (per-user quota tracking)**

NOTE: This task was primarily implemented during Task 1 as part of the store client foundation. This verification confirms all requirements are met:

- ✅ `marketplaceRateLimits` table created in `convex/schema.ts` (Task 1):

  - Per-business-account, per-provider quota tracking
  - 24-hour rolling window with automatic reset
  - Circuit breaker state management
  - Alert threshold at 80%
  - All fields: windowStart, requestCount, capacity, windowDurationMs, alertThreshold, alertEmitted, consecutiveFailures, circuitBreakerOpenUntil

- ✅ Internal functions in `convex/functions/marketplace.ts` (Task 1):

  - `getQuotaState()` - Query current quota with defaults for new accounts
  - `incrementQuota()` - Atomic increment with window reset logic
  - `recordFailure()` - Circuit breaker tracking (opens after 5 failures)
  - `resetFailures()` - Reset on successful request

- ✅ Pre-flight quota check in `BricklinkStoreClient.request()` (Task 1):

  - Queries quota state before every API request
  - Checks circuit breaker state
  - Validates quota capacity
  - Throws `RATE_LIMIT_EXCEEDED` with `retryAfterMs` on exceeded quota
  - Throws `CIRCUIT_BREAKER_OPEN` with `retryAfterMs` on circuit open

- ✅ Post-request quota recording (Task 1):

  - Increments quota after successful API call
  - Resets consecutive failures on success
  - Window automatically resets after 24 hours

- ✅ Quota alert metric emission (improved in Task 5):

  - Added post-increment quota check in store client
  - Emits `external.bricklink.store.quota.alert` when 80% threshold reached
  - Alert flag prevents duplicate metric spam
  - Includes businessAccountId, provider, count, capacity, percentage

- ✅ Tenant isolation verified:
  - All quota functions require businessAccountId parameter
  - Separate quota tracking per business account
  - Independent from global BrickOps catalog quota
  - Circuit breaker operates per tenant

**Task 6: Resiliency patterns (exponential backoff and retry logic)**

- Added retry configuration types to `convex/bricklink/storeClient.ts`:

  - `RetryConfig` - Configuration interface (maxRetries, initialDelayMs, maxDelayMs, backoffMultiplier)
  - `DEFAULT_RETRY_CONFIG` - Default policy: 5 retries, 1s initial delay, 32s max delay, 2x multiplier

- Refactored `request()` method to support retry logic:

  - Determines if operation is safe to retry (GET, PUT, DELETE = safe; POST = not safe)
  - Delegates to `executeWithRetry()` wrapper for retry logic
  - POST operations explicitly set maxRetries=0 to prevent non-idempotent retries

- Implemented `executeWithRetry()` method - Exponential backoff retry wrapper:

  - Retries up to maxRetries times (default: 5)
  - Exponential backoff: 1s → 2s → 4s → 8s → 16s → 32s (capped at maxDelayMs)
  - Checks if error is retryable before each retry attempt
  - Extracts Retry-After header for HTTP 429 responses
  - Records retry attempt metrics with attempt number and delay
  - Throws on final attempt or non-retryable errors

- Implemented `isRetryableError()` method - Smart retry detection:

  - ✅ Retries transient errors: HTTP 5xx, HTTP 429, network errors, timeouts
  - ❌ Never retries: Client errors (4xx except 429), auth errors (401/403)
  - ❌ Never retries: Our own quota errors (RATE_LIMIT_EXCEEDED, CIRCUIT_BREAKER_OPEN)
  - ❌ Never retries: Credential errors (INVALID_CREDENTIALS)

- Implemented `extractRetryAfter()` method - HTTP 429 handling:

  - Parses Retry-After header from error message (best-effort)
  - Converts seconds to milliseconds
  - Falls back to exponential backoff if not found

- Implemented `makeRequest()` method - Core request logic:

  - Original request logic extracted from `request()` method
  - Maintains all quota checking and error handling
  - Now wrapped by retry logic for safe operations

- Circuit breaker integration (from Task 1):

  - Already implemented in `makeRequest()` pre-flight checks
  - Opens after 5 consecutive failures
  - Blocks requests for 5 minutes
  - Throws `CIRCUIT_BREAKER_OPEN` with retryAfterMs

- CRITICAL safety guarantees:
  - ✅ POST operations NEVER auto-retry (non-idempotent)
  - ✅ Only safe operations retry (GET, PUT, DELETE)
  - ✅ Quota errors don't retry (would waste attempts)
  - ✅ Auth errors don't retry (would fail again)
  - ✅ Circuit breaker prevents retry storms

**Task 7: Structured logging and metrics**

NOTE: Most metrics were already implemented in previous tasks. This task verifies completeness and adds missing metrics.

- ✅ Correlation ID generation (Tasks 1, 4, 6):

  - Generated in `request()` method: `crypto.randomUUID()`
  - Passed to `makeRequest()` and through retry logic
  - Included in all metrics for distributed tracing
  - Included in bulk operation results for per-item tracking

- ✅ Complete metric coverage using `recordMetric()`:

  - `external.bricklink.store.request` - Request start (added in Task 7)
  - `external.bricklink.store.success` - Successful requests (Task 1)
  - `external.bricklink.store.error` - Failed requests with error type (Task 1)
  - `external.bricklink.store.retry` - Retry attempts with attempt number (Task 6)
  - `external.bricklink.store.quota.blocked` - Quota exceeded (Task 1)
  - `external.bricklink.store.quota.alert` - 80% threshold reached (Task 5)
  - `external.bricklink.store.circuit_breaker.blocked` - Circuit open (Task 1)
  - `external.bricklink.store.bulk.progress` - Bulk operation progress (added in Task 7)

- ✅ Request metadata logging:

  - `correlationId` - Unique ID for request tracing
  - `operation` - API endpoint path
  - `businessAccountId` - Tenant context
  - `method` - HTTP method (GET, POST, PUT, DELETE)
  - `durationMs` - Request latency
  - For bulk: `completed`, `total`, `currentBatch`, `totalBatches`
  - For retry: `attempt`, `maxRetries`, `delayMs`

- ✅ Error metadata logging:

  - `correlationId` - Request tracing
  - `operation` - Failed endpoint
  - `errorType` or `httpStatus` - Error classification
  - `businessAccountId` - Tenant context
  - `durationMs` - Time to failure
  - Error details via `normalizeApiError()` - Structured error formatting

- ✅ Security verified - NO sensitive data logged:

  - Credentials NEVER logged (only used in Authorization header construction)
  - Authorization headers NEVER logged (only passed to fetch)
  - OAuth signature NEVER logged (only passed to fetch)
  - Only businessAccountId logged for tenant tracking (not credential values)

- ✅ Bulk operation metrics:

  - Progress metrics track: completed, total, currentBatch, totalBatches
  - Emitted after each batch for real-time monitoring
  - Separate operations: bulkCreate, bulkUpdate, bulkDelete
  - Enables UI progress bars and observability dashboards

- ✅ Consistent error formatting:
  - All errors use `normalizeApiError()` helper
  - Structured error shape across all operations
  - Includes endpoint, status, body, correlationId
  - Provider context ("bricklink") for multi-marketplace tracking

**Task 8: Unit tests with HTTP mocking**

- SKIPPED per user request - will be addressed separately

**Task 9: Client factory with credential decryption (Story 3.1 integration)**

NOTE: This task was fully implemented in Task 1 as part of the marketplace infrastructure. Verification confirms all requirements met:

- ✅ `createBricklinkStoreClient()` function in `convex/functions/marketplace.ts` (Task 1):

  - Helper function (not internal action - returns non-serializable client instance)
  - Accepts: `ctx: ActionCtx`, `businessAccountId: Id<"businessAccounts">`
  - Returns: `Promise<BricklinkStoreClient>`

- ✅ Credential retrieval and validation:

  - Queries `marketplaceCredentials` via `getEncryptedCredentials()` internal query
  - Filters by businessAccountId and provider="bricklink"
  - Checks `isActive` flag (handled in `getEncryptedCredentials` - returns null if inactive)
  - Throws user-friendly error: "BrickLink credentials not configured. Please add your credentials in Settings."

- ✅ Credential decryption:

  - Decrypts all 4 OAuth 1.0a credentials using `decryptCredential()` from `convex/lib/encryption.ts`
  - Individual fields: consumerKey, consumerSecret, tokenValue, tokenSecret
  - Decryption happens server-side in action context (never exposed to client)

- ✅ Client instantiation:

  - Creates `new BricklinkStoreClient(decryptedCreds, businessAccountId, ctx)`
  - Passes ActionCtx for database-backed rate limiting
  - Client validates credentials in constructor (throws if missing fields)
  - Returns ready-to-use client instance

- ✅ RBAC correctly deferred:

  - Factory does NOT check user role (as specified)
  - RBAC will be enforced in Story 3.4 orchestration layer
  - Factory is internal helper - only callable from server-side actions

- ✅ Usage pattern for Story 3.4:
  ```typescript
  const client = await createBricklinkStoreClient(ctx, businessAccountId);
  const inventories = await client.getInventories();
  ```

**Task 10: Rollback and compensating operations support (Story 3.4 rollback capability)**

- ✅ Verified CRUD operations support rollback patterns:

  - `createInventory()` returns full `BricklinkInventoryResponse` with `inventory_id`
  - `updateInventory()` returns full response with all updated fields
  - `deleteInventory()` accepts inventoryId for deletion
  - All responses include necessary data for compensating operations

- Created `convex/marketplaces/types.ts` with shared interfaces:

  - `StoreOperationResult` - Standardized result format with rollback data support
  - `MarketplaceCredentials` - Decrypted credential structure
  - `RateLimitState` - Quota state structure
  - `RollbackOperation` - Rollback operation descriptor
  - `DryRunResult` - Dry-run validation result

- Added dry-run mode support to CRUD operations:

  - `createInventory(payload, { dryRun: true })` - Validates create without API call
  - `updateInventory(id, payload, { dryRun: true })` - Validates update without API call
  - `deleteInventory(id, { dryRun: true })` - Validates delete without API call
  - Dry-run runs full validation, returns mock response
  - Enables Story 3.4 rollback preview: "Show me what will happen if I undo this"

- Added validation helper methods:

  - `validateCreatePayload()` - Validates all required fields for create
    - Checks: item.no, item.type, color_id, quantity, unit_price, new_or_used
    - Throws structured `VALIDATION_ERROR` with field-specific messages
  - `validateUpdatePayload()` - Validates update payload
    - Checks quantity delta syntax (+/- prefix required)
    - Validates price format (fixed-point number string)

- Documented rollback patterns in storeClient.ts header:

  - **CREATE rollback**: Save inventory_id → call deleteInventory(id)
  - **UPDATE rollback**: Save previous values → call updateInventory(id, previousValues) with reversed deltas
  - **DELETE rollback**: Save full payload before delete → call createInventory(originalPayload)
  - **Quantity delta reversal**: "+5" becomes "-5", "-3" becomes "+3"

- Added `OperationOptions` interface:

  - `dryRun?: boolean` - Validate without executing

- Integration with inventoryAuditLogs (Story 3.4):

  - Audit logs will store: changeType, previousValues, newValues
  - UI will display change history with "Undo" buttons
  - Undo button calls appropriate compensating operation
  - Dry-run mode enables "Preview Undo" functionality

- Rollback data requirements met:
  - Create returns: inventory_id (for delete rollback)
  - Update returns: full inventory response (for update rollback with previous values)
  - Delete needs: full original payload stored in audit log (for create rollback)
  - All operations return enough data for Story 3.4 to construct compensating operations

### File List

**Created:**

- `convex/bricklink/oauth.ts` (112 lines)
- `convex/bricklink/storeClient.ts` (1,283 lines - complete with CRUD, bulk, rate limiting, retry, metrics, dry-run)
- `convex/bricklink/storeMappers.ts` (251 lines - bidirectional data mappers)
- `convex/marketplaces/types.ts` (89 lines - shared interfaces for Story 3.4 integration)

**Modified:**

- `convex/bricklink/catalogClient.ts` (renamed from `bricklinkClient.ts`, refactored OAuth signing, export renamed to `catalogClient`, 422 lines)
- `convex/functions/marketplace.ts` (added rate limiting + client factory, 763 lines)
- `convex/schema.ts` (added marketplaceRateLimits table + extended inventoryItems, 353 lines)

**Total:** 4 new files, 3 modified files

## QA Results

_(Populated by QA Agent after implementation)_
