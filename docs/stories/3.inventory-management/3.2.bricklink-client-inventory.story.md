# Story 3.2: BrickLink Store Client (Inventory Lots + Mappers)

## Status

Done

## Story

**As a** system,
**I want** a robust BrickLink client with inventory lot CRUD and data mappers,
**so that** we can synchronize our users' store inventory to/from BrickLink in a reliable and maintainable way.

## Acceptance Criteria

1. **3.2.1:** Implement a typed BrickLink client that authenticates with user-provided credentials and supports required OAuth 1.0a signing.
2. **3.2.2:** Provide CRUD operations for store inventory lots: create lot, read/get lot(s), update lot, delete lot; include list/pagination support where the API allows.
3. **3.2.3:** Implement data mappers to transform BrickLink request/response payloads into our Convex `inventories` schema shapes and back (including fields like part identifier, condition, quantity, price, location, remarks/notes, status).
4. **3.2.4:** Support bulk operations where BrickLink API enables them; if not supported natively, provide chunked/sequenced operations with progress and partial-failure reporting.
5. **3.2.5:** Add resiliency: handle rate limits and transient failures via exponential backoff, retry policies, and idempotency (dedupe by request keys).
6. **3.2.6:** Provide structured logging (with correlation IDs) and metrics around request counts, latency, errors, and throttle events; no secrets in logs.
7. **3.2.7:** Include unit tests using HTTP mocking to validate signing, mapping correctness, error handling, and rate-limit behavior.

## Tasks / Subtasks

- [ ] Task 1: Refactor OAuth signing and create specialized inventory client (AC: 3.2.1)

  - [ ] **Extract Shared OAuth Logic**: Create `convex/bricklink/oauth.ts` module with reusable OAuth 1.0a signing functions:
    - Extract `percentEncode()` helper from existing `BricklinkClient`
    - Extract OAuth signature generation logic into `generateOAuthSignature(credentials, method, url, params)` function
    - Extract Authorization header building into `buildAuthorizationHeader(credentials, signature, oauthParams)` function
    - Add `generateOAuthParams(timestamp, nonce)` helper for OAuth parameter construction
    - CRITICAL: Make functions pure and testable (accept credentials as parameter, not from env)
  - [ ] **Refactor Existing Catalog Client** (`convex/bricklink/bricklinkClient.ts`):
    - Replace inline OAuth logic with calls to shared `oauth.ts` functions
    - Keep existing credential source (environment variables via `getBricklinkCredentials()`)
    - Keep existing static in-memory quota tracking (works for single credential set)
    - Keep existing catalog methods (colors, categories, parts, price guides)
    - No breaking changes - this is internal refactor for code reuse
  - [ ] **Create New Store Client** (`convex/bricklink/storeClient.ts`):
    - New class that accepts user credentials and `businessAccountId` as constructor arguments
    - Use shared OAuth functions from `oauth.ts` for signing
    - Implement database-backed rate limiting (pre-flight check + post-request recording)
    - Implement store inventory CRUD methods (separate from catalog methods)
    - CRITICAL: Use user credentials passed to constructor (NOT env variables)
    - NOTE: Named "Store" not "Inventory" - will also handle orders in Epic 4
  - [ ] Add validation to ensure credentials are properly formatted before making requests in both clients
  - [ ] [Source: docs/architecture/backend-architecture.md#actions-external-api-orchestration; docs/external-documentation/api-bricklink/authentication.md; docs/stories/3.1.user-marketplace-credentials-byok-on-settings.story.md#dev-notes]

- [ ] Task 2: Implement inventory lot CRUD operations (AC: 3.2.2)

  - [ ] Implement `getInventories(options?: { itemType?, status?, categoryId?, colorId? })` method for listing inventory lots with filtering support (maps to `GET /inventories`)
  - [ ] Implement `getInventory(inventoryId: number)` method for fetching single inventory lot (maps to `GET /inventories/{inventory_id}`)
  - [ ] Implement `createInventory(payload)` method for creating single inventory lot (maps to `POST /inventories`)
  - [ ] Implement `createInventories(payloads[])` method for **NATIVE** bulk inventory creation - sends array in single API call (maps to `POST /inventories` with array body, returns `{ meta, data: null }`)
  - [ ] Implement `updateInventory(inventoryId: number, payload)` method for updating single inventory lot (maps to `PUT /inventories/{inventory_id}`)
  - [ ] Implement `deleteInventory(inventoryId: number)` method for deleting single inventory lot (maps to `DELETE /inventories/{inventory_id}`)
  - [ ] CRITICAL: Quantity updates must use +/- delta syntax per BrickLink API requirements (e.g., `quantity: "+5"` or `quantity: "-3"`)
  - [ ] CRITICAL: BrickLink supports native bulk CREATE only - UPDATE and DELETE are single-item operations requiring chunking (see Task 4)
  - [ ] [Source: docs/external-documentation/api-bricklink/inventory.md; docs/prd/epic-3-inventory-management.md#story-32]

- [ ] Task 3: Implement data mappers for BrickLink <-> Convex schema (AC: 3.2.3)

  - [ ] Create `convex/bricklink/storeMappers.ts` with bidirectional mapper functions for store data (inventory now, orders in Epic 4)
  - [ ] Implement `mapBricklinkToConvexInventory(bricklinkInventory)` to transform BrickLink inventory response to our `inventoryItems` schema (map: `inventory_id` → `bricklinkInventoryId`, `item.no` → `partNumber`, `color_id` → `colorId`, `quantity` → `quantityAvailable`, `new_or_used` → `condition`, `unit_price` → `price`, `description` → `notes`, `is_stock_room`/`stock_room_id` → `location`)
  - [ ] Implement `mapConvexToBricklinkInventory(convexInventory)` to transform our inventory to BrickLink create/update payload (reverse mapping with proper field names and format)
  - [ ] Handle optional fields gracefully (e.g., BrickLink's `completeness` only for SET type, tier pricing, bulk settings)
  - [ ] Include TypeScript types for BrickLink inventory request/response shapes based on API documentation
  - [ ] Add validation for required fields and proper enum values (condition: "N"/"U", item type, etc.)
  - [ ] [Source: docs/external-documentation/api-bricklink/inventory.md; docs/architecture/data-models.md#inventoryitem; docs/architecture/backend-architecture.md#function-template]

- [ ] Task 4: Implement bulk operations with chunking (AC: 3.2.4)

  - [ ] **BULK CREATE (Native BrickLink Support - Most Efficient)**:
    - Implement `bulkCreateInventories(payloads[], options?: { chunkSize?, onProgress? })` that chunks into batches and calls native `createInventories()` (single API call per chunk)
    - Default chunk size: 100 items per batch (BrickLink recommended limit for reliable processing)
    - BrickLink API accepts array in single POST: `POST /inventories` with `[{...}, {...}]` body - returns `{ meta, data: null }` on success
    - This is HIGHLY EFFICIENT: 100 inventory creations = 1 API call (vs 100 calls for individual creates)
    - Critical for Story 3.4 initial bulk sync when user first connects BrickLink
    - **GOTCHA**: Bulk create returns `null` data (no inventory IDs) - if IDs needed, must query after: `GET /inventories` and match by part/color/condition, OR use individual creates (trades efficiency for immediate ID tracking)
  - [ ] **BULK UPDATE (No Native Support - Sequential Required)**:
    - Implement `bulkUpdateInventories(updates[], options?)` that sequences individual `updateInventory()` calls (no native bulk API)
    - Each update requires separate `PUT /inventories/{id}` call - BrickLink does not support batch updates
    - Chunk into batches of 50 to manage rate limiting and provide progress feedback
    - Add delay between chunks (e.g., 100ms) to avoid rate limit spikes
  - [ ] **BULK DELETE (No Native Support - Sequential Required)**:
    - Implement `bulkDeleteInventories(ids[], options?)` that sequences individual `deleteInventory()` calls (no native bulk API)
    - Each delete requires separate `DELETE /inventories/{id}` call
    - Chunk into batches of 50 with progress tracking
  - [ ] **Common Bulk Features**:
    - Add progress callback: `onProgress({ completed: number, total: number, currentBatch: number, totalBatches: number })`
    - Track partial failures: collect all errors with context (batch index, item index, error details) and return comprehensive result: `{ succeeded: number, failed: number, errors: Array<{ batchIndex, itemIndex, item, error }> }`
    - Add idempotency: dedupe requests by generating stable request key (hash of payload) and skip duplicate operations within same bulk batch
    - CRITICAL: Support external idempotency keys via `options.idempotencyKey?` parameter - Story 3.4 will pass change log IDs for deduplication across retry attempts
    - Return structured result for each operation: `{ success: boolean, bricklinkInventoryId?: number, error?: { code, message, details }, marketplaceStatus?: string }` to support Story 3.4 sync status tracking
  - [ ] **Rate Limit Optimization**: Track API calls consumed: bulk create of 100 items = 1 call, bulk update of 100 items = 100 calls - balance batch size with quota conservation
  - [ ] [Source: docs/external-documentation/api-bricklink/inventory.md#create-store-inventories; docs/prd/epic-3-inventory-management.md#story-32-notes; docs/prd/epic-3-inventory-management.md#story-34; docs/architecture/backend-architecture.md#actions-external-api-orchestration]

- [ ] Task 5: Database-backed rate limiting (AC: 3.2.5 - per-user quota tracking)

  - [ ] Create `marketplaceRateLimits` table in schema (if not exists) for persistent quota tracking per business account and provider
  - [ ] Create internal queries in `convex/functions/marketplace.ts`: `getQuotaState(businessAccountId, provider)` returns current quota usage and capacity
  - [ ] Create internal mutation in `convex/functions/marketplace.ts`: `incrementQuota(businessAccountId, provider)` atomically increments request count with window reset logic
  - [ ] In `BricklinkStoreClient.request()`: implement pre-flight quota check by calling `getQuotaState()` before making API request
  - [ ] If quota exceeded, throw `ConvexError` with code `RATE_LIMIT_EXCEEDED`, include `retryAfterMs` for Story 3.4 retry scheduling
  - [ ] In `BricklinkStoreClient.request()`: implement post-request quota recording by calling `incrementQuota()` after successful API call
  - [ ] Add quota alert at 80% threshold: emit metric `external.bricklink.store.quota.alert` when business account reaches warning level
  - [ ] CRITICAL: Quota tracking is per business account (tenant-isolated) and separate from global BrickOps catalog quota
  - [ ] [Source: docs/architecture/backend-architecture.md#actions-external-api-orchestration; docs/prd/epic-3-inventory-management.md#story-32]

- [ ] Task 6: Resiliency patterns (AC: 3.2.5)

  - [ ] Implement exponential backoff for transient failures (HTTP 5xx, network errors): start with 1s delay, double each retry up to max 32s, max 5 retries
  - [ ] Handle BrickLink HTTP 429 responses: extract `Retry-After` header if available, implement respectful backoff
  - [ ] Implement circuit breaker pattern: if 5 consecutive failures for a business account, temporarily disable that account's BrickLink sync for 5 minutes (track in `marketplaceRateLimits` table with `circuitBreakerOpenUntil` field)
  - [ ] Add retry policy configuration: `{ maxRetries: 5, initialDelayMs: 1000, maxDelayMs: 32000, backoffMultiplier: 2 }`
  - [ ] CRITICAL: Never retry non-idempotent operations (POST create) automatically; only retry safe operations (GET, PUT with same payload, DELETE)
  - [ ] [Source: docs/architecture/backend-architecture.md#actions-external-api-orchestration; docs/architecture/coding-standards.md#critical-rules]

- [ ] Task 7: Structured logging and metrics (AC: 3.2.6)

  - [ ] Add correlation ID generation for all operations: `crypto.randomUUID()` passed through entire request chain
  - [ ] Use existing `recordMetric()` helper from `convex/lib/external/metrics.ts` for tracking: `external.bricklink.store.request`, `external.bricklink.store.success`, `external.bricklink.store.error`, `external.bricklink.store.retry`, `external.bricklink.store.quota`
  - [ ] Log request metadata: `{ correlationId, operation, businessAccountId, itemCount (for bulk), durationMs, retryCount }`
  - [ ] Log error details: `{ correlationId, operation, errorCode, errorMessage, httpStatus, businessAccountId }` - NEVER log credential values or auth headers
  - [ ] Add metric for bulk operation progress: `external.bricklink.store.bulk.progress { completed, total, batchIndex }`
  - [ ] Reuse existing `normalizeApiError()` from `convex/lib/external/types.ts` for consistent error formatting
  - [ ] [Source: docs/architecture/backend-architecture.md#convex-function-patterns-and-best-practices; docs/prd/epic-3-inventory-management.md#story-32]

- [ ] Task 8: Unit tests with HTTP mocking (AC: 3.2.7)

  - [ ] Create `__tests__/backend/bricklink-store-client.test.ts` using Vitest and HTTP mocking
  - [ ] Test OAuth 1.0a signing correctness: mock timestamp and nonce, verify generated Authorization header matches expected signature
  - [ ] Test CRUD operations: mock BrickLink API responses for each operation (get, list, create, update, delete), verify request payloads and response parsing
  - [ ] Test data mapper bidirectional conversion: verify BrickLink → Convex and Convex → BrickLink transformations preserve all fields correctly
  - [ ] Test bulk operations: verify chunking logic, progress callbacks, partial failure handling
  - [ ] Test database-backed rate limiting:
    - Mock quota queries/mutations
    - Verify pre-flight quota check prevents API call when quota exceeded
    - Verify post-request quota recording increments counter
    - Test window reset logic (24-hour rollover)
    - Test alert threshold triggers (80% capacity)
    - Test circuit breaker opens after 5 consecutive failures
    - Verify `RATE_LIMIT_EXCEEDED` error includes `retryAfterMs` for Story 3.4 scheduling
  - [ ] Test exponential backoff: simulate transient failures, verify retry delays follow expected backoff pattern
  - [ ] Test error handling: simulate various HTTP error codes (400, 401, 403, 404, 429, 500), verify proper error normalization and logging
  - [ ] Use `BricklinkStoreClient.createForTesting()` factory with mocked credentials, fixed timestamp/nonce for deterministic tests
  - [ ] [Source: docs/architecture/testing-strategy.md#backend-tests; docs/architecture/coding-standards.md#testing-standards]

- [ ] Task 9: Client factory with credential decryption (Story 3.1 integration)

  - [ ] Create internal action `marketplace.createBricklinkStoreClient(businessAccountId)` in `convex/functions/marketplace.ts`
  - [ ] Action queries `marketplaceCredentials` table for the business account's BrickLink credentials (provider: "bricklink")
  - [ ] If no credentials found or inactive, throw `ConvexError` with user-friendly message: "BrickLink credentials not configured. Please add your credentials in Settings."
  - [ ] Decrypt credentials using `decryptCredential()` from `convex/lib/encryption.ts`
  - [ ] Instantiate `BricklinkStoreClient` with: decrypted credentials, businessAccountId, AND ActionCtx (`ctx`) - client needs ctx for DB rate limiting
  - [ ] Return client instance ready for store operations (inventory now, orders in Epic 4)
  - [ ] Add RBAC check: only owner role can trigger store sync operations (check in Story 3.4 orchestration layer, not here)
  - [ ] CRITICAL: Client constructor signature is `new BricklinkStoreClient(credentials, businessAccountId, ctx)` - ctx enables database queries/mutations for quota tracking
  - [ ] [Source: docs/stories/3.1.user-marketplace-credentials-byok-on-settings.story.md#dev-notes; docs/architecture/backend-architecture.md#authentication-and-authorization; docs/architecture/backend-architecture.md#internal-functions-server-only-building-blocks]

- [ ] Task 10: Rollback and compensating operations support (Story 3.4 rollback capability)

  - [ ] All CRUD operations already support rollback pattern: `createInventory` → `deleteInventory`, `deleteInventory` → `createInventory` (with same payload), `updateInventory` → `updateInventory` (with previous values)
  - [ ] Ensure all operation responses include enough information for Story 3.4 to construct compensating operations: `{ bricklinkInventoryId, previousQuantity?, previousPrice?, etc. }`
  - [ ] Document rollback patterns in Dev Notes: for each operation type, specify the inverse operation and required data
  - [ ] Add support for "dry-run" mode via `options.dryRun?: boolean` - validates operation without executing (for Story 3.4 rollback preview)
  - [ ] [Source: docs/prd/epic-3-inventory-management.md#story-34-ac-347; docs/architecture/backend-architecture.md#actions-external-api-orchestration]

## Dev Notes

### Quick Reference: Which Client to Use?

**Use `bricklinkClient` (Catalog Client) for:**

- ✅ Global catalog data: colors, categories, parts, price guides
- ✅ BrickOps system operations (uses BrickOps credentials)
- ✅ Shared across all users
- ✅ Example: `await bricklinkClient.getRefreshedPart("3001")`

**Use `BricklinkStoreClient` (Store Client) for:**

- ✅ User's BrickLink store operations (inventory + orders)
- ✅ BYOK operations (uses user's marketplace credentials)
- ✅ Per-business-account operations
- ✅ Example: `const client = await createBricklinkStoreClient(businessAccountId); await client.getInventories()`

**Never:**

- ❌ Use catalog client for store endpoints (inventory, orders)
- ❌ Use store client for catalog endpoints (colors, parts)
- ❌ Mix BrickOps credentials with user store operations
- ❌ Mix user credentials with catalog operations

### Previous Story Insights

- Story 3.1 (User Marketplace Credentials) established secure credential storage with encryption at rest and test connection functionality. This story builds on that foundation by implementing the actual BrickLink inventory API client that consumes those user credentials.
- Story 2.3 (Advanced Catalog Management) implemented the BrickLink client for catalog data using BrickOps environment credentials. This story creates a parallel "Store" client for user's marketplace store management (inventory now, orders in Epic 4) using user marketplace credentials (BYOK model).
- [Source: docs/stories/3.1.user-marketplace-credentials-byok-on-settings.story.md; docs/stories/2.part-identification-catalog-integration/2.3.advanced-catalog-management.story.md]

### CRITICAL: Separate Specialized Clients Architecture

**Why Two Clients? (Pattern Justification)**

BrickOps uses **separate specialized clients** for catalog vs store, NOT a single unified client. This architectural decision is driven by fundamental differences:

| Aspect                 | Catalog Client                              | Store Client                                   |
| ---------------------- | ------------------------------------------- | ---------------------------------------------- |
| **Credentials Source** | Environment variables (BrickOps)            | User database (BYOK)                           |
| **Rate Limiting**      | Static in-memory (global quota)             | Database-backed (per-tenant)                   |
| **Quota Pool**         | Single shared pool (5K/day)                 | Independent per business account               |
| **Methods**            | Catalog queries (colors, parts, categories) | Store operations (inventory, orders, settings) |
| **Instantiation**      | Singleton (`bricklinkClient`)               | Factory per request (user-specific)            |
| **Tenant Context**     | None (global catalog)                       | Requires `businessAccountId`                   |
| **Scope**              | Global reference data                       | User's marketplace store                       |

**Shared Code:** OAuth 1.0a signing logic extracted to `convex/bricklink/oauth.ts`

**1. Catalog Client (Existing - Story 2.3, Refactored in This Story):**

- **File**: `convex/bricklink/bricklinkClient.ts`
- **Credentials**: BrickOps environment variables via `getBricklinkCredentials()`
- **Purpose**: Query BrickLink catalog for part data, colors, categories (global reference data)
- **Quota Tracking**: Static in-memory class property (works for single credential set)
- **Rate Limiting**: Pre-request check increments static counter, throws on exceeded
- **Instantiation**: Singleton export `export const bricklinkClient = new BricklinkClient()`
- **Used By**: `catalog.searchParts`, `catalog.getPartDetails`, catalog refresh crons
- **Refactor**: Replace inline OAuth logic with shared `oauth.ts` functions (no breaking changes)

**2. Store Client (This Story - 3.2, Net New):**

- **File**: `convex/bricklink/storeClient.ts`
- **Credentials**: User marketplace credentials from `marketplaceCredentials` table (decrypted at runtime)
- **Purpose**: Manage user's BrickLink store (inventory in Story 3.2, orders in Epic 4, settings future)
- **Quota Tracking**: Database-backed via `marketplaceRateLimits` table (persistent, distributed-safe)
- **Rate Limiting**: Pre-flight queries DB, post-request mutates DB atomically per business account
- **Instantiation**: Factory pattern via internal action `createBricklinkStoreClient(businessAccountId)`
- **Used By**: Inventory sync actions (Story 3.4), order sync (Epic 4), user-initiated store operations
- **Constructor**: `new BricklinkStoreClient(userCredentials, businessAccountId, ctx)`

**CRITICAL: Never Mix Credentials**

```typescript
// ❌ WRONG - Using catalog client for user store operations
const catalogClient = bricklinkClient; // Uses BrickOps credentials
await catalogClient.request({ path: "/inventories" }); // User store endpoint!
// This would query BrickOps store inventory, not the user's!

// ✅ CORRECT - Use specialized clients
// For catalog (system credentials)
const catalogData = await bricklinkClient.getRefreshedPart("3001");

// For store (user credentials)
const storeClient = await ctx.runAction(internal.marketplace.createBricklinkStoreClient, {
  businessAccountId,
});
const userInventory = await storeClient.getInventories();
const userOrders = await storeClient.getOrders(); // Epic 4
```

**Refactoring Strategy:**

1. Extract shared OAuth logic to `oauth.ts` (pure functions)
2. Refactor `BricklinkClient` to use shared OAuth (internal cleanup)
3. Create `BricklinkStoreClient` using shared OAuth (net new)
4. Each client maintains its own rate limiting strategy (appropriate to use case)

**Directory Structure (Final State After Story 3.2):**

```text
convex/
├── bricklink/
│   ├── bricklinkClient.ts     # Catalog client (unchanged file name, refactored internally)
│   ├── bricklinkMappers.ts    # Catalog mappers (unchanged file name)
│   ├── dataRefresher.ts       # Catalog refresh jobs (unchanged)
│   ├── oauth.ts               # NEW - Shared OAuth 1.0a signing helpers
│   ├── storeClient.ts         # NEW - Store client (inventory + future orders)
│   └── storeMappers.ts        # NEW - Store data mappers
│
├── marketplaces/
│   └── types.ts               # NEW - Shared TypeScript interfaces across all marketplaces
│                              #   - StoreOperationResult
│                              #   - MarketplaceCredentials
│                              #   - RateLimitState
│
├── functions/
│   ├── marketplace.ts         # EXTEND - Add createBricklinkStoreClient() factory + rate limiting
│   └── inventory.ts           # Business logic (unchanged)
```

**Future: After Story 3.3 (BrickOwl):**

```text
convex/
├── bricklink/
│   └── ... (as above)
│
├── brickowl/
│   ├── storeClient.ts         # BrickOwl store client
│   ├── storeMappers.ts        # BrickOwl store mappers
│   └── auth.ts                # API key helpers
│
├── marketplaces/
│   └── types.ts               # Shared across BrickLink + BrickOwl
```

**Naming Rationale:**

- **"Store"** not "Inventory": BrickLink API calls it "store API" - encompasses inventory, orders, settings
- **Future-proof**: Store client will add order methods in Epic 4 without rename
- **Semantic accuracy**: User's marketplace store vs global part catalog
- **No breaking changes**: Keep existing catalog file names (only refactor internals)

**Class Structure for Store Client:**

```typescript
// convex/bricklink/storeClient.ts
import { ActionCtx } from "../_generated/server";
import { generateOAuthSignature, buildAuthorizationHeader } from "./oauth";

interface BricklinkUserCredentials {
  consumerKey: string;
  consumerSecret: string;
  tokenValue: string;
  tokenSecret: string;
}

export class BricklinkStoreClient {
  private readonly credentials: BricklinkUserCredentials;
  private readonly businessAccountId: Id<"businessAccounts">;
  private readonly ctx: ActionCtx; // Needed for DB rate limiting

  constructor(
    credentials: BricklinkUserCredentials,
    businessAccountId: Id<"businessAccounts">,
    ctx: ActionCtx,
  ) {
    this.credentials = credentials;
    this.businessAccountId = businessAccountId;
    this.ctx = ctx;
  }

  async request(options: RequestOptions) {
    // 1. Check quota (DB query)
    const quota = await this.ctx.runQuery(internal.marketplace.getQuotaState, {
      businessAccountId: this.businessAccountId,
      provider: "bricklink",
    });

    // Validate quota...

    // 2. Sign request using shared OAuth functions
    const signature = await generateOAuthSignature(this.credentials, method, url, params);

    const authorization = buildAuthorizationHeader(this.credentials, signature, oauthParams);

    // 3. Make API call
    const response = await fetch(url, { headers: { Authorization: authorization } });

    // 4. Record usage (DB mutation)
    await this.ctx.runMutation(internal.marketplace.incrementQuota, {
      businessAccountId: this.businessAccountId,
      provider: "bricklink",
    });

    return response;
  }

  // Story 3.2: Inventory CRUD methods
  async getInventories(...): Promise<BricklinkInventory[]>
  async createInventory(...): Promise<BricklinkInventory>
  async createInventories(...): Promise<void>
  async updateInventory(...): Promise<BricklinkInventory>
  async deleteInventory(...): Promise<void>

  // Epic 4: Order methods (placeholder for future)
  // async getOrders(...): Promise<BricklinkOrder[]>
  // async updateOrderStatus(...): Promise<BricklinkOrder>
}
```

**Catalog Client Refactor (No Breaking Changes):**

```typescript
// convex/bricklink/bricklinkClient.ts (refactored)
import { generateOAuthSignature, buildAuthorizationHeader } from "./oauth";

export class BricklinkClient {
  // Keep existing: env credentials, static quota, singleton pattern

  async request(options: RequestOptions) {
    // 1. Check quota (existing static logic)
    BricklinkClient.recordQuotaUsage(); // No change

    // 2. Sign request using SHARED OAuth functions (refactored)
    const signature = await generateOAuthSignature(
      this.credentials, // From env
      method,
      url,
      params,
    );

    const authorization = buildAuthorizationHeader(this.credentials, signature, oauthParams);

    // 3. Make API call (no change)
    const response = await fetch(url, { headers: { Authorization: authorization } });

    return response;
  }

  // Keep existing: catalog methods (colors, categories, parts, price guides)
}

// Keep singleton export
export const bricklinkClient = new BricklinkClient();
```

[Source: docs/architecture/backend-architecture.md#catalog-data-refresh-lifecycle; docs/architecture/backend-architecture.md#internal-functions-server-only-building-blocks; docs/stories/3.1.user-marketplace-credentials-byok-on-settings.story.md#dev-notes]

### Database-Backed Rate Limiting Architecture

**Layer Responsibilities:**

1. **Client Layer** (`BricklinkStoreClient`) - Enforcement

   - Pre-flight quota check before each API request
   - Post-request quota recording after successful call
   - Throws structured error when quota exceeded

2. **Database Layer** (Convex mutations/queries in `marketplace.ts`)

   - Persistent quota state per business account
   - Atomic increment operations
   - Window reset logic (24-hour rolling)
   - Circuit breaker state tracking

3. **Orchestration Layer** (Story 3.4)
   - Handles rate limit errors gracefully
   - Schedules retries after quota resets
   - Updates UI with quota status

**Schema: marketplaceRateLimits Table**

```typescript
// convex/schema.ts - extend with rate limiting table
marketplaceRateLimits: defineTable({
  businessAccountId: v.id("businessAccounts"),
  provider: v.union(v.literal("bricklink"), v.literal("brickowl")),

  // Quota tracking
  windowStart: v.number(),           // Unix timestamp when current window started
  requestCount: v.number(),          // Requests made in current window
  capacity: v.number(),              // Max requests per window (5000 for BrickLink)
  windowDurationMs: v.number(),      // Window size in ms (86400000 = 24 hours)

  // Alerting
  alertThreshold: v.number(),        // Percentage (0-1) to trigger alert (default: 0.8)
  alertEmitted: v.boolean(),         // Whether alert has been sent for current window

  // Circuit breaker
  consecutiveFailures: v.number(),   // Track failures for circuit breaker
  circuitBreakerOpenUntil: v.optional(v.number()), // If set, circuit is open

  // Metadata
  lastRequestAt: v.number(),
  lastResetAt: v.number(),
  createdAt: v.number(),
  updatedAt: v.number(),
})
  .index("by_business_provider", ["businessAccountId", "provider"]),
```

**Implementation Pattern:**

```typescript
// Client pre-flight check
class BricklinkStoreClient {
  async request(options) {
    // 1. Check quota BEFORE making request
    const quota = await ctx.runQuery(internal.marketplace.getQuotaState, {
      businessAccountId: this.businessAccountId,
      provider: "bricklink",
    });

    // Check window reset
    const now = Date.now();
    const windowElapsed = now - quota.windowStart;
    const isWindowExpired = windowElapsed >= quota.windowDurationMs;

    // Check circuit breaker
    if (quota.circuitBreakerOpenUntil && now < quota.circuitBreakerOpenUntil) {
      throw new ConvexError({
        code: "CIRCUIT_BREAKER_OPEN",
        message: "BrickLink sync temporarily disabled due to repeated failures",
        retryAfterMs: quota.circuitBreakerOpenUntil - now,
      });
    }

    // Check quota (skip if window expired, will reset on increment)
    if (!isWindowExpired && quota.requestCount >= quota.capacity) {
      const resetIn = quota.windowStart + quota.windowDurationMs - now;
      throw new ConvexError({
        code: "RATE_LIMIT_EXCEEDED",
        message: `BrickLink rate limit exceeded (${quota.requestCount}/${quota.capacity}). Resets in ${Math.ceil(resetIn / 60000)} minutes.`,
        retryAfterMs: resetIn,
        currentUsage: quota.requestCount,
        capacity: quota.capacity,
      });
    }

    // 2. Make API request
    let response;
    try {
      response = await fetch(url, { ... });
    } catch (error) {
      // Record failure for circuit breaker
      await ctx.runMutation(internal.marketplace.recordFailure, {
        businessAccountId: this.businessAccountId,
        provider: "bricklink",
      });
      throw error;
    }

    // 3. Record quota usage AFTER successful request
    await ctx.runMutation(internal.marketplace.incrementQuota, {
      businessAccountId: this.businessAccountId,
      provider: "bricklink",
    });

    return response;
  }
}

// Database mutations
export const incrementQuota = internalMutation({
  args: { businessAccountId: v.id("businessAccounts"), provider: v.string() },
  handler: async (ctx, { businessAccountId, provider }) => {
    const now = Date.now();
    const existing = await ctx.db
      .query("marketplaceRateLimits")
      .withIndex("by_business_provider", q =>
        q.eq("businessAccountId", businessAccountId).eq("provider", provider)
      )
      .first();

    // Initialize if first request
    if (!existing) {
      await ctx.db.insert("marketplaceRateLimits", {
        businessAccountId,
        provider,
        windowStart: now,
        requestCount: 1,
        capacity: 5000, // BrickLink limit
        windowDurationMs: 86400000, // 24 hours
        alertThreshold: 0.8,
        alertEmitted: false,
        consecutiveFailures: 0,
        lastRequestAt: now,
        lastResetAt: now,
        createdAt: now,
        updatedAt: now,
      });
      return;
    }

    // Check if window expired
    const windowElapsed = now - existing.windowStart;
    if (windowElapsed >= existing.windowDurationMs) {
      // Reset window
      await ctx.db.patch(existing._id, {
        windowStart: now,
        requestCount: 1,
        alertEmitted: false,
        consecutiveFailures: 0, // Reset failures on new window
        lastRequestAt: now,
        lastResetAt: now,
        updatedAt: now,
      });
      return;
    }

    // Increment counter
    const newCount = existing.requestCount + 1;
    const percentage = newCount / existing.capacity;

    // Check alert threshold
    const shouldAlert = percentage >= existing.alertThreshold && !existing.alertEmitted;

    await ctx.db.patch(existing._id, {
      requestCount: newCount,
      alertEmitted: shouldAlert ? true : existing.alertEmitted,
      lastRequestAt: now,
      updatedAt: now,
    });

    // Emit alert metric
    if (shouldAlert) {
      recordMetric("external.bricklink.store.quota.alert", {
        businessAccountId,
        provider,
        count: newCount,
        capacity: existing.capacity,
        percentage,
      });
    }
  },
});

export const getQuotaState = internalQuery({
  args: { businessAccountId: v.id("businessAccounts"), provider: v.string() },
  handler: async (ctx, { businessAccountId, provider }) => {
    const quota = await ctx.db
      .query("marketplaceRateLimits")
      .withIndex("by_business_provider", q =>
        q.eq("businessAccountId", businessAccountId).eq("provider", provider)
      )
      .first();

    // Return defaults if no quota record exists
    if (!quota) {
      return {
        windowStart: Date.now(),
        requestCount: 0,
        capacity: 5000,
        windowDurationMs: 86400000,
        alertThreshold: 0.8,
        alertEmitted: false,
        consecutiveFailures: 0,
        circuitBreakerOpenUntil: undefined,
      };
    }

    return quota;
  },
});

export const recordFailure = internalMutation({
  args: { businessAccountId: v.id("businessAccounts"), provider: v.string() },
  handler: async (ctx, { businessAccountId, provider }) => {
    const existing = await ctx.db
      .query("marketplaceRateLimits")
      .withIndex("by_business_provider", q =>
        q.eq("businessAccountId", businessAccountId).eq("provider", provider)
      )
      .first();

    if (!existing) return; // No quota record yet

    const newFailures = existing.consecutiveFailures + 1;
    const now = Date.now();

    // Open circuit breaker after 5 consecutive failures
    const updates: any = {
      consecutiveFailures: newFailures,
      updatedAt: now,
    };

    if (newFailures >= 5) {
      updates.circuitBreakerOpenUntil = now + (5 * 60 * 1000); // 5 minutes

      recordMetric("external.bricklink.store.circuit_breaker.open", {
        businessAccountId,
        provider,
        consecutiveFailures: newFailures,
      });
    }

    await ctx.db.patch(existing._id, updates);
  },
});
```

**Why Database-Backed:**

- ✅ Persistent across Convex isolate restarts
- ✅ Shared state across distributed backend instances
- ✅ Enables future UI quota dashboard
- ✅ Audit trail for debugging
- ✅ Supports per-tenant (business account) isolation
- ✅ Circuit breaker state persists

**Performance Considerations:**

- Pre-flight check is a fast indexed query (< 5ms)
- Post-request increment is single atomic write
- Circuit breaker prevents wasted API calls when service is down
- Alert threshold prevents metric spam

[Source: docs/architecture/backend-architecture.md#convex-function-patterns-and-best-practices; docs/prd/epic-3-inventory-management.md#story-32]

### Bulk Operations Strategy for API Efficiency

**BrickLink API Bulk Capabilities:**

BrickLink provides **native bulk support for CREATE only**. This has significant implications for API quota management:

| Operation       | Native Bulk?    | API Calls for 100 Items | Efficiency         |
| --------------- | --------------- | ----------------------- | ------------------ |
| **CREATE**      | ✅ Yes          | **1 call**              | **100x efficient** |
| **UPDATE**      | ❌ No           | 100 calls               | Standard           |
| **DELETE**      | ❌ No           | 100 calls               | Standard           |
| **READ (list)** | ✅ Yes (filter) | 1 call                  | Efficient          |

**Critical Efficiency Pattern:**

```typescript
// ✅ HIGHLY EFFICIENT - Native bulk create (1 API call)
await client.createInventories([
  { item: { no: "3001", type: "PART" }, color_id: 1, quantity: 10, ... },
  { item: { no: "3002", type: "PART" }, color_id: 2, quantity: 5, ... },
  // ... 100 items
]); // Single POST /inventories with array body

// ❌ INEFFICIENT - Individual creates (100 API calls)
for (const item of items) {
  await client.createInventory(item); // 100 separate POST calls
}
```

**Implementation Requirements:**

1. **Bulk Create** (Task 2 + 4):

   - Use native `POST /inventories` with array body
   - Chunk size: 100 items (BrickLink recommended maximum)
   - Critical for Story 3.4 initial sync: syncing 1,000 inventory items = **10 API calls** instead of 1,000
   - Response: `{ meta, data: null }` (no individual IDs returned in bulk response)
   - **ID Tracking Strategy**: After bulk create, call `GET /inventories` and match items by unique key (partNumber + colorId + condition) to populate `bricklinkInventoryId` in Convex
   - **Trade-off**: Bulk create (10 calls) + fetch IDs (1 call) = 11 total calls vs 1,000 individual creates - still **90x more efficient**

2. **Bulk Update** (Task 4):

   - No native support - must sequence individual `PUT /inventories/{id}` calls
   - Chunk size: 50 items with inter-chunk delay (100ms) to smooth rate limiting
   - Progress tracking essential for long-running updates

3. **Bulk Delete** (Task 4):
   - No native support - must sequence individual `DELETE /inventories/{id}` calls
   - Chunk size: 50 items with progress tracking

**Rate Limit Impact:**

Given BrickLink's 5,000 requests/day quota per account:

- **Bulk Create**: Can sync 500,000 new items/day (100 items × 5,000 calls)
- **Bulk Update**: Can update 5,000 items/day (1 item × 5,000 calls)
- **Bulk Delete**: Can delete 5,000 items/day (1 item × 5,000 calls)

**Story 3.4 Integration - Initial Sync Optimization:**

When user first connects BrickLink, Story 3.4 should use this efficient pattern:

```typescript
// Efficient initial sync pattern with ID tracking

// Option 1: Pull from BrickLink → Convex (import existing inventory)
const bricklinkInventories = await client.getInventories(); // 1 API call (gets all)
await bulkImportToConvex(bricklinkInventories.map(mapBricklinkToConvexInventory)); // All inventory IDs already present in response

// Option 2: Push from Convex → BrickLink (export local to marketplace)
const convexInventories = await getAllLocalInventories();

// Step 1: Bulk create on BrickLink (highly efficient)
await client.bulkCreateInventories(convexInventories.map(mapConvexToBricklinkInventory), {
  chunkSize: 100,
  onProgress: (p) => updateUI(p),
}); // ~10 API calls for 1000 items

// Step 2: Fetch BrickLink IDs to enable future syncing (1 additional call)
const createdInventories = await client.getInventories(); // 1 API call

// Step 3: Match and update Convex records with BrickLink IDs
for (const bricklinkItem of createdInventories) {
  const convexItem = findMatchingConvexItem(
    bricklinkItem.item.no, // partNumber
    bricklinkItem.color_id, // colorId
    bricklinkItem.new_or_used, // condition
  );

  if (convexItem) {
    await updateConvexWithBricklinkId(convexItem._id, bricklinkItem.inventory_id);
  }
}

// Total: ~11 API calls for 1000 items (still 90x more efficient than individual creates)
```

**Matching Strategy for Bulk Create ID Resolution:**

Create unique composite key from: `${partNumber}-${colorId}-${condition}`

```typescript
// Build lookup map from BrickLink results
const bricklinkMap = new Map(
  createdInventories.map((item) => [
    `${item.item.no}-${item.color_id}-${item.new_or_used}`,
    item.inventory_id,
  ]),
);

// Match Convex items to BrickLink IDs
for (const convexItem of convexInventories) {
  const key = `${convexItem.partNumber}-${convexItem.colorId}-${convexItem.condition === "new" ? "N" : "U"}`;
  const bricklinkId = bricklinkMap.get(key);

  if (bricklinkId) {
    convexItem.bricklinkInventoryId = bricklinkId;
  }
}
```

**Edge Case - Duplicate Parts:**

If user has multiple lots of same part-color-condition combination:

- BrickLink allows duplicate inventory lots (same part, different prices/locations)
- Matching by composite key may be ambiguous
- Story 3.4 should handle: match by additional fields (price, quantity, date) or use individual creates for better tracking

````

**Key Principles:**

- ✅ **Always use bulk create** when adding multiple items
- ✅ **Batch updates/deletes** to show progress and handle partial failures
- ✅ **Monitor quota usage** - track API calls consumed, not just items processed
- ✅ **Provide progress feedback** - especially for sequential operations
- ✅ **Handle partial failures gracefully** - continue processing remaining items

[Source: docs/external-documentation/api-bricklink/inventory.md#create-store-inventories; docs/prd/epic-3-inventory-management.md#story-32; docs/prd/epic-3-inventory-management.md#story-34]

### Data Models

**BrickLink Inventory API Response Shape:**

```typescript
interface BricklinkInventoryResponse {
  inventory_id: number;
  item: {
    no: string; // Part number
    name: string;
    type:
      | "PART"
      | "SET"
      | "MINIFIG"
      | "BOOK"
      | "GEAR"
      | "CATALOG"
      | "INSTRUCTION"
      | "UNSORTED_LOT"
      | "ORIGINAL_BOX";
    category_id: number;
  };
  color_id: number;
  color_name: string;
  quantity: number;
  new_or_used: "N" | "U"; // N = New, U = Used
  completeness?: "C" | "B" | "S"; // C = Complete, B = Incomplete, S = Sealed (SET only)
  unit_price: string; // Fixed point number as string (e.g., "1.2000")
  bind_id: number;
  description: string;
  remarks: string;
  bulk: number; // Buyers can buy only in multiples of this amount
  is_retain: boolean; // Retains in inventory after sold out
  is_stock_room: boolean; // Only in owner's inventory (not public)
  stock_room_id?: "A" | "B" | "C";
  date_created: string; // ISO timestamp
  my_cost?: string; // Fixed point number
  sale_rate?: number; // Sale percentage (e.g., 20 for 20% off)
  tier_quantity1?: number;
  tier_price1?: string;
  tier_quantity2?: number;
  tier_price2?: string;
  tier_quantity3?: number;
  tier_price3?: string;
}
````

[Source: docs/external-documentation/api-bricklink/inventory.md]

**Convex inventoryItems Schema (Target Mapping):**

```typescript
{
  businessAccountId: Id<"businessAccounts">;
  sku: string; // Derived from partNumber + colorId + condition
  name: string;
  partNumber: string; // Maps from item.no
  colorId: string; // Maps from color_id (stored as string)
  location: string; // Maps from stock_room_id or custom field
  quantityAvailable: number; // Maps from quantity
  quantityReserved: number;
  quantitySold: number;
  status: "available" | "reserved" | "sold";
  condition: "new" | "used"; // Maps from new_or_used: "N" → "new", "U" → "used"
  price?: number; // Maps from unit_price (parse string to number)
  notes?: string; // Maps from description or remarks
  bricklinkInventoryId?: number; // Maps from inventory_id (track BrickLink sync)
  createdBy: Id<"users">;
  createdAt: number;
  updatedAt?: number;
  isArchived?: boolean;
  deletedAt?: number;
}
```

[Source: docs/architecture/database-schema.md#inventoryitems; docs/architecture/data-models.md#inventoryitem]

**Mapping Strategy:**

- **Quantity Delta Pattern**: BrickLink requires quantity updates as deltas ("+5", "-3"), not absolute values. When syncing from Convex → BrickLink, calculate delta from previous known quantity.
- **Stock Room → Location**: BrickLink uses `is_stock_room` boolean + `stock_room_id` enum; map to our flexible `location` string field (e.g., "Stockroom A", "Stockroom B", or custom locations).
- **SKU Generation**: Create unique SKU from `partNumber-colorId-condition` (e.g., "3001-5-new") for duplicate prevention.
- **Sync Tracking**: Store `bricklinkInventoryId` in our schema to track which Convex inventory items are synced to BrickLink and enable bidirectional updates.

[Source: docs/external-documentation/api-bricklink/inventory.md#update-store-inventory; docs/prd/epic-3-inventory-management.md#story-32]

### API Specifications

**BrickLink Inventory Endpoints:**

```typescript
// List inventories (bulk read)
GET /inventories?item_type={type}&status={status}&category_id={id}&color_id={id}
Response: { meta, data: BricklinkInventoryResponse[] }
Note: Returns all matching inventories - efficient for initial sync

// Get single inventory
GET /inventories/{inventory_id}
Response: { meta, data: BricklinkInventoryResponse }

// Create single inventory
POST /inventories
Body: { item: { no, type }, color_id, quantity, unit_price, new_or_used, ... }
Response: { meta, data: BricklinkInventoryResponse }

// ⭐ Create multiple inventories (NATIVE BULK - HIGHLY EFFICIENT)
POST /inventories
Body: [{ item: { no, type }, ... }, { item: { no, type }, ... }, ...]
Response: { meta, data: null } // Returns empty data on success
Note: 100 items = 1 API call - use this for Story 3.4 initial bulk sync!

// Update single inventory (NO BULK SUPPORT - must loop)
PUT /inventories/{inventory_id}
Body: { quantity: "+5", unit_price: "1.50", ... } // Quantity MUST be delta with +/- prefix
Response: { meta, data: BricklinkInventoryResponse }
Note: BrickLink does not support bulk update - 100 updates = 100 API calls

// Delete single inventory (NO BULK SUPPORT - must loop)
DELETE /inventories/{inventory_id}
Response: { meta, data: null }
Note: BrickLink does not support bulk delete - 100 deletes = 100 API calls
```

**Critical API Constraints:**

- Quantity updates MUST use delta syntax: `"+10"` to add, `"-5"` to subtract
- Tier pricing requires all 6 fields to be present (tier_quantity1-3, tier_price1-3)
- `completeness` field only valid for item type "SET"
- All price fields are fixed-point strings (e.g., "1.2000")
- Status parameter uses single letters: "Y" (available), "S"/"B"/"C" (stockroom), "N" (unavailable), "R" (reserved)

**Bulk Create Limitation:**

- Native bulk create (`POST /inventories` with array) returns `{ meta, data: null }` - **does NOT return inventory IDs**
- To get BrickLink inventory IDs after bulk create, must call `GET /inventories` to fetch and match by part number + color + condition
- Alternative: Use individual creates when inventory IDs are needed immediately (trade efficiency for ID tracking)
- Story 3.4 should handle this: bulk create for initial sync, then query to populate `bricklinkInventoryId` fields in Convex

[Source: docs/external-documentation/api-bricklink/inventory.md#create-store-inventories]

### Component Specifications

N/A - This story is backend-only (no frontend components).

### File Locations

**Backend:**

- **Shared OAuth**: `convex/bricklink/oauth.ts` (new file - pure OAuth 1.0a signing functions extracted from existing client)
- **Catalog Client** (Story 2.3): `convex/bricklink/bricklinkClient.ts` (refactor to use shared OAuth helpers - **NO breaking changes**)
- **Store Client** (This Story): `convex/bricklink/storeClient.ts` (new file - uses shared OAuth + DB rate limiting for store operations)
- **Store Mappers**: `convex/bricklink/storeMappers.ts` (new file - bidirectional BrickLink store ↔ Convex mapping, handles inventory now + orders in Epic 4)
- **Marketplace Functions**: `convex/functions/marketplace.ts` (extend with `createBricklinkStoreClient()` factory + rate limiting mutations/queries)
- **Marketplace Types**: `convex/marketplaces/types.ts` (new file - shared interfaces across all marketplace providers)
- **Schema**: `convex/schema.ts` (add `marketplaceRateLimits` table)

**Tests:**

- OAuth Functions: `__tests__/backend/bricklink-oauth.test.ts` (test extracted OAuth logic)
- Store Client: `__tests__/backend/bricklink-store-client.test.ts` (test store CRUD + rate limiting)
- Store Mappers: `__tests__/backend/bricklink-store-mappers.test.ts` (test bidirectional mapping)
- Catalog Client Refactor: Update `__tests__/backend/bricklink-client.test.ts` if it exists (verify no breaking changes)

[Source: docs/architecture/unified-project-structure.md; docs/architecture/testing-strategy.md#test-organization]

### Technical Constraints

**OAuth 1.0a Signing (User Credentials):**

- Reuse existing OAuth implementation from `BricklinkClient` but parameterize with user credentials
- Extract signing logic to shared `oauth.ts` module for DRY principle
- User credentials stored encrypted; must decrypt at runtime using `decryptCredential()` from Story 3.1
- NEVER log credential values or Authorization headers in any logs/metrics

**Quantity Delta Syntax:**

- BrickLink API requires quantity updates as strings with +/- prefix (e.g., `"+5"`, `"-3"`)
- This prevents race conditions when quantity changes between read and update
- Always calculate delta from last known quantity; never send absolute quantity values
- Create inventories can use absolute quantity (no prefix), updates MUST use delta

**Rate Limiting and Quota (Database-Backed):**

- **Architecture**: Database-backed quota tracking using `marketplaceRateLimits` Convex table
- **Isolation**: User inventory operations have separate quota from BrickOps catalog operations; each business account has independent rate limit (BrickLink enforces per API credential)
- **Enforcement**: Client layer performs pre-flight quota check and post-request recording via internal mutations/queries
- **Persistence**: Quota state persists across restarts and is shared across all Convex backend instances
- **Circuit Breaker**: Track consecutive failures; temporarily disable sync after 5 failures to prevent account suspension
- **Alerting**: Emit metric at 80% threshold; reset alert flag when window resets
- **HTTP 429 Handling**: Respect BrickLink's `Retry-After` header; calculate retry time from quota window
- **Window Reset**: 24-hour rolling window with automatic reset logic in `incrementQuota` mutation
- **Future UI**: Quota state queryable for Settings page dashboard ("2,847 / 5,000 requests used today")

**Idempotency:**

- Generate request key (hash of payload) to dedupe bulk operations within same batch
- Support external idempotency keys via `options.idempotencyKey` - Story 3.4 will pass change log IDs
- NEVER auto-retry non-idempotent operations (POST create) - only safe operations (GET, PUT, DELETE)
- For bulk creates, if partial failure occurs, return detailed error report with failed items and allow manual retry

**Structured Result Format (for Story 3.4 Integration):**

All CRUD operations return standardized result format for sync status tracking:

```typescript
// Defined in convex/marketplaces/types.ts
interface StoreOperationResult {
  success: boolean;
  bricklinkInventoryId?: number; // For inventory create/update/get operations
  bricklinkOrderId?: number; // For order operations (Epic 4)
  error?: {
    code: string; // e.g., "CONFLICT", "VALIDATION_ERROR", "RATE_LIMIT", "NOT_FOUND"
    message: string; // User-friendly error message
    details?: any; // Additional error context
  };
  marketplaceStatus?: string; // BrickLink's status field if available
  correlationId: string; // For tracing
}
```

This enables Story 3.4 to:

- Track sync status per change (`success` flag)
- Update Convex records with BrickLink IDs (`bricklinkInventoryId`)
- Detect conflicts for UI display (`error.code === "CONFLICT"`)
- Provide detailed error messages to users (`error.message`)

**Note:** Interface is generic "Store" operation to support both inventory (Story 3.2) and orders (Epic 4).

[Source: docs/external-documentation/api-bricklink/authentication.md; docs/external-documentation/api-bricklink/inventory.md; docs/architecture/backend-architecture.md#actions-external-api-orchestration; docs/prd/epic-3-inventory-management.md#story-34]

### Error Handling

**Backend:**

- Use `ConvexError` for user-facing errors with helpful messages:
  - "BrickLink credentials not configured" → guide to settings page
  - "BrickLink API rate limit exceeded" → show retry-after time
  - "Invalid inventory data" → show which fields failed validation
- Use `normalizeApiError()` helper from `convex/lib/external/types.ts` for consistent error formatting
- Log all errors server-side with correlation ID but return safe messages to client
- Handle BrickLink API errors gracefully:
  - HTTP 400 (Bad Request) → validation error, surface field-level details
  - HTTP 401 (Unauthorized) → credentials expired/invalid, prompt user to re-authenticate
  - HTTP 404 (Not Found) → inventory item doesn't exist on BrickLink
  - HTTP 429 (Too Many Requests) → rate limit, show wait time
  - HTTP 500 (Server Error) → transient failure, retry with backoff

**Bulk Operation Error Handling:**

- Track partial failures with detailed context: `{ batchIndex, itemIndex, item, error }`
- Return comprehensive result: `{ succeeded: number, failed: number, errors: Array<...> }`
- Allow caller to decide whether to retry failed items or surface errors to user
- Log bulk operation summary: `{ correlationId, totalItems, succeeded, failed, durationMs }`

[Source: docs/architecture/error-handling-strategy.md; docs/architecture/backend-architecture.md#function-template; docs/prd/epic-3-inventory-management.md#story-32]

### Security Considerations

**Credential Protection:**

- User marketplace credentials decrypted only server-side in actions (never exposed to client)
- Use `internal` actions for client creation - NEVER expose credential retrieval as public API
- RBAC enforcement: only owner role can trigger inventory sync operations
- All API requests log correlation ID but NEVER log credential values, auth headers, or sensitive data

**Tenant Isolation:**

- All operations require `businessAccountId` parameter
- Verify user belongs to business account before creating inventory client
- Rate limiting tracked per business account (separate quota per tenant)
- Never expose one tenant's BrickLink data to another tenant

**Rate Limiting:**

- Respect BrickLink's rate limits to avoid account suspension
- Implement circuit breaker: disable sync for account after repeated failures
- Surface clear error messages to users when rate limited (don't expose technical details)

[Source: docs/architecture/security-and-performance.md#security-requirements; docs/architecture/backend-architecture.md#authentication-and-authorization]

### Integration with Story 3.1 (Marketplace Credentials)

**Credential Retrieval and Client Factory Pattern:**

```typescript
// convex/functions/marketplace.ts
export const createBricklinkStoreClient = internalAction({
  args: { businessAccountId: v.id("businessAccounts") },
  handler: async (ctx, { businessAccountId }) => {
    // 1. Query marketplace credentials
    const credentials = await ctx.runQuery(internal.marketplace.getEncryptedCredentials, {
      businessAccountId,
      provider: "bricklink",
    });

    if (!credentials || !credentials.isActive) {
      throw new ConvexError("BrickLink credentials not configured");
    }

    // 2. Decrypt credentials
    const decryptedCreds = {
      consumerKey: await decryptCredential(credentials.bricklinkConsumerKey),
      consumerSecret: await decryptCredential(credentials.bricklinkConsumerSecret),
      tokenValue: await decryptCredential(credentials.bricklinkTokenValue),
      tokenSecret: await decryptCredential(credentials.bricklinkTokenSecret),
    };

    // 3. Create and return client with ActionCtx for DB rate limiting
    // CRITICAL: Pass ctx so client can call internal queries/mutations for quota tracking
    return new BricklinkStoreClient(
      decryptedCreds,
      businessAccountId,
      ctx, // ActionCtx enables DB-backed rate limiting
    );
  },
});
```

**Why ActionCtx is Required:**

The store client needs `ActionCtx` to:

- Call `ctx.runQuery(internal.marketplace.getQuotaState, ...)` for pre-flight quota checks
- Call `ctx.runMutation(internal.marketplace.incrementQuota, ...)` for post-request recording
- Call `ctx.runMutation(internal.marketplace.recordFailure, ...)` for circuit breaker tracking

This is why the client is instantiated **inside an action**, not as a singleton like the catalog client.

[Source: docs/stories/3.1.user-marketplace-credentials-byok-on-settings.story.md#dev-notes; docs/architecture/backend-architecture.md#internal-functions-server-only-building-blocks]

### Integration with Story 3.4 (Orchestration Layer)

Story 3.4 will consume this client to sync inventory changes. Here are the key integration patterns:

**Pattern 1: Per-Change Sync (Story 3.4 Change Log Processing)**

```typescript
// Story 3.4 sync action will process change log entries one at a time
export const syncInventoryChange = internalAction({
  args: { changeId: v.id("inventoryChangeLog") },
  handler: async (ctx, { changeId }) => {
    // Get change details
    const change = await ctx.runQuery(internal.inventory.getChange, { changeId });

    // Create client
    const client = await ctx.runAction(internal.marketplace.createBricklinkStoreClient, {
      businessAccountId: change.businessAccountId,
    });

    // Execute sync with idempotency key (change ID)
    let result;
    switch (change.changeType) {
      case "create":
        result = await client.createInventory(change.newData, {
          idempotencyKey: changeId,
        });
        break;
      case "update":
        result = await client.updateInventory(change.bricklinkInventoryId, change.delta, {
          idempotencyKey: changeId,
        });
        break;
      case "delete":
        result = await client.deleteInventory(change.bricklinkInventoryId, {
          idempotencyKey: changeId,
        });
        break;
    }

    // Update sync status
    await ctx.runMutation(internal.inventory.updateSyncStatus, {
      changeId,
      provider: "bricklink",
      success: result.success,
      bricklinkInventoryId: result.bricklinkInventoryId,
      error: result.error,
      syncedAt: Date.now(),
    });
  },
});
```

**Pattern 2: Bulk Initial Sync (Story 3.4 First-Time Setup)**

```typescript
// Story 3.4 will support bulk initial sync when user first connects BrickLink
export const initialBulkSync = internalAction({
  args: { businessAccountId: v.id("businessAccounts") },
  handler: async (ctx, { businessAccountId }) => {
    const client = await ctx.runAction(internal.marketplace.createBricklinkStoreClient, {
      businessAccountId,
    });

    // Pull all BrickLink inventory
    const bricklinkInventories = await client.getInventories();

    // Bulk import to Convex with progress tracking
    const results = await ctx.runMutation(internal.inventory.bulkImportFromBricklink, {
      businessAccountId,
      inventories: bricklinkInventories.map(mapBricklinkToConvexInventory),
    });

    return { imported: results.succeeded, failed: results.failed };
  },
});
```

**Pattern 3: Rollback Support (Story 3.4 AC 3.4.7)**

```typescript
// Story 3.4 will support rolling back inventory changes
export const rollbackChange = internalAction({
  args: { changeId: v.id("inventoryChangeLog") },
  handler: async (ctx, { changeId }) => {
    const change = await ctx.runQuery(internal.inventory.getChange, { changeId });
    const client = await ctx.runAction(internal.marketplace.createBricklinkStoreClient, {
      businessAccountId: change.businessAccountId,
    });

    // Execute compensating operation
    let compensatingResult;
    switch (change.changeType) {
      case "create":
        // Rollback create = delete
        compensatingResult = await client.deleteInventory(change.bricklinkInventoryId, {
          idempotencyKey: `rollback-${changeId}`,
        });
        break;
      case "update":
        // Rollback update = update with previous values
        compensatingResult = await client.updateInventory(
          change.bricklinkInventoryId,
          change.previousData,
          { idempotencyKey: `rollback-${changeId}` },
        );
        break;
      case "delete":
        // Rollback delete = recreate
        compensatingResult = await client.createInventory(change.previousData, {
          idempotencyKey: `rollback-${changeId}`,
        });
        break;
    }

    // Record rollback in change log
    await ctx.runMutation(internal.inventory.recordRollback, {
      originalChangeId: changeId,
      compensatingResult,
    });
  },
});
```

**Pattern 4: Conflict Detection (Story 3.4 AC 3.4.5)**

```typescript
// Story 3.4 handles conflicts when BrickLink rejects updates
if (!result.success && result.error?.code === "CONFLICT") {
  // Surface to UI: "Inventory on BrickLink was modified externally"
  await ctx.runMutation(internal.inventory.markConflict, {
    changeId,
    conflictDetails: result.error.details,
  });
}
```

**Key Requirements for Story 3.4 Integration:**

1. ✅ Client supports per-operation calls (not just bulk)
2. ✅ Client accepts external idempotency keys (change IDs)
3. ✅ Client returns structured results for sync status tracking
4. ✅ Client supports rollback via inverse operations
5. ✅ Client provides detailed error responses for conflict handling
6. ✅ Client includes correlation IDs for tracing through sync pipeline

[Source: docs/prd/epic-3-inventory-management.md#story-34; docs/architecture/backend-architecture.md#internal-functions-server-only-building-blocks]

### Testing Approach

**Unit Tests (Vitest):**

- Mock HTTP requests using test factories
- Mock `crypto` functions for deterministic OAuth signing tests
- Verify mapper functions with comprehensive fixtures covering all BrickLink field variations
- Test quota tracking, backoff logic, error normalization in isolation

**Integration Tests (Future - Story 3.4):**

- Story 3.4 (Convex Orchestration Layer) will add integration tests for end-to-end sync flows
- Will test: Convex → BrickLink sync, BrickLink → Convex sync, conflict resolution, rollback scenarios

**HTTP Mocking Pattern:**

```typescript
// Mock fetch for deterministic tests
global.fetch = jest.fn((url, options) => {
  if (url.includes("/inventories")) {
    return Promise.resolve({
      ok: true,
      status: 200,
      headers: new Headers(),
      json: async () => ({ meta: {}, data: mockBricklinkInventoryResponse }),
    });
  }
  throw new Error(`Unmocked endpoint: ${url}`);
});
```

[Source: docs/architecture/testing-strategy.md#backend-tests; docs/architecture/coding-standards.md#testing-standards]

## Change Log

| Date       | Version | Description                                                                                                                                                                 | Author |
| ---------- | ------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------ |
| 2025-10-09 | v1.0    | Initial draft of Story 3.2                                                                                                                                                  | Bob    |
| 2025-10-09 | v1.1    | Enhanced for Story 3.4 integration: added idempotency keys, structured results, rollback support, and comprehensive usage patterns                                          | Bob    |
| 2025-10-09 | v1.2    | Added database-backed rate limiting: marketplaceRateLimits table, per-tenant quota tracking, circuit breaker, detailed implementation patterns                              | Bob    |
| 2025-10-09 | v1.3    | Clarified bulk operation efficiency: emphasized native bulk CREATE (100x efficient), documented ID tracking strategy, noted UPDATE/DELETE are single-item only              | Bob    |
| 2025-10-09 | v1.4    | Clarified separate specialized clients architecture: catalog vs inventory, shared OAuth extraction, refactoring strategy, comprehensive class structures and usage patterns | Bob    |
| 2025-10-09 | v1.5    | Renamed to "Store" pattern: BricklinkStoreClient for inventory + future orders, added directory structure, updated all references to use store terminology                  | Bob    |

## Dev Agent Record

### Agent Model Used

_(Populated by Dev Agent after implementation)_

### Debug Log References

_(Populated by Dev Agent after implementation)_

### Completion Notes List

_(Populated by Dev Agent after implementation)_

### File List

_(Populated by Dev Agent after implementation)_

## QA Results

_(Populated by QA Agent after implementation)_
